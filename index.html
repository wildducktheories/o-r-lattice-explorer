<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>O-R Lattice: Collatz Sequence Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2em;
            margin-bottom: 10px;
            color: #4a9eff;
        }

        .subtitle {
            color: #999;
            font-size: 0.9em;
        }

        .controls {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .control-row {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        label {
            font-weight: 500;
            min-width: 80px;
        }

        input[type="number"],
        input[type="text"] {
            background: #1a1a1a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 1em;
            width: 200px;
        }

        input[type="number"]:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: #4a9eff;
        }

        button {
            background: #4a9eff;
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 4px;
            font-size: 1em;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }

        button:hover {
            background: #3a8eef;
        }

        button:active {
            background: #2a7edf;
        }

        .canvas-container {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            overflow: auto;
        }

        canvas {
            display: block;
            background: #1a1a1a;
            border: 1px solid #444;
            cursor: crosshair;
        }

        .info-panel {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .info-section {
            margin-bottom: 15px;
        }

        .info-section:last-child {
            margin-bottom: 0;
        }

        .info-label {
            font-weight: 500;
            color: #4a9eff;
            margin-bottom: 5px;
        }

        .info-value {
            font-family: 'Courier New', monospace;
            color: #e0e0e0;
            padding: 8px;
            background: #1a1a1a;
            border-radius: 4px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .congruence-link {
            color: #4a9eff;
            text-decoration: none;
            cursor: pointer;
            padding: 0 2px;
        }

        .congruence-link:hover {
            color: #6bb3ff;
            text-decoration: underline;
        }

        .congruence-link:active {
            color: #88c5ff;
        }

        .succ-x-link {
            color: #4a9eff;
            text-decoration: none;
            cursor: pointer;
            padding: 0 2px;
        }

        .succ-x-link:hover {
            color: #6bb3ff;
            text-decoration: underline;
        }

        .succ-x-link:active {
            color: #88c5ff;
        }

        .selected-block-section {
            margin-top: 10px;
            padding: 10px 15px;
            background: #333;
            border-radius: 4px;
            border: 1px solid #4a9eff;
        }

        .selected-block-label {
            font-weight: 500;
            color: #4a9eff;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .selected-block-content {
            font-family: 'Courier New', monospace;
            color: #e0e0e0;
            padding: 8px;
            background: #1a1a1a;
            border-radius: 4px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .selected-block-nav {
            margin-top: 8px;
            font-family: 'Courier New', monospace;
            color: #e0e0e0;
        }

        canvas {
            user-select: none;
        }

        .error {
            background: #4a1a1a;
            color: #ff6b6b;
            padding: 10px 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            border: 1px solid #ff6b6b;
        }

        .popout-icon {
            float: right;
            cursor: pointer;
            font-size: 18px;
            color: #4a9eff;
            padding: 2px 6px;
            border-radius: 3px;
            user-select: none;
        }

        .popout-icon:hover {
            background-color: rgba(74, 158, 255, 0.1);
            color: #6bb3ff;
        }

        .section-header {
            position: relative;
            margin-bottom: 10px;
        }

        .canvas-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .controls-header {
            background-color: #1a1a1a;
            padding: 8px 15px;
            margin: -10px -10px 15px -10px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .controls-title {
            color: #4a9eff;
            font-weight: bold;
            font-size: 1.1em;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>O-R Lattice: Collatz Sequence Visualizer</h1>
            <div class="subtitle">Explore 3x+1 sequences through the (o,r) coordinate system
            <br>üì¶ <a href="https://github.com/wildducktheories/o-r-lattice-explorer" target="_blank" style="color: #ffffff; text-decoration: underline;">Source Code</a> |
            üìÑ <a href="https://github.com/wildducktheories/o-r-lattice-explorer/blob/master/papers/affine-block-structures.pdf" target="_blank" style="color: #ffffff; text-decoration: underline;">Paper</a></div>
        </header>

        <div id="errorPanel" class="error" style="display: none;"></div>

        <div class="canvas-container">
            <div class="canvas-header">
                <h2 style="color: #4a9eff; margin: 0;">O-R Lattice</h2>
                <span class="popout-icon" id="popoutLatticeBtn" title="Pop out lattice">‚ßâ</span>
            </div>
            <canvas id="latticeCanvas" width="1200" height="800"></canvas>
        </div>

        <div class="info-panel">
            <div class="info-section">
                <div class="info-label">Sequence (OE notation):</div>
                <div id="oeSequence" class="info-value">-</div>
            </div>
        </div>

        <div id="selectedBlockSection" class="selected-block-section" style="display: none;">
            <div class="selected-block-label">
                Selected Block
                <span class="popout-icon" id="popoutSelectedBlockBtn" title="Pop out selected block">‚ßâ</span>
            </div>
            <div id="selectedBlockPattern" class="info-value" style="margin-bottom: 10px;">-</div>
            <div class="selected-block-content" id="selectedBlockContent"></div>
        </div>

        <div class="controls">
            <div class="controls-header">
                <span class="controls-title">Controls</span>
                <span class="popout-icon" id="popoutControlsBtn" title="Pop out controls">‚ßâ</span>
            </div>
            <div class="control-row">
                <label for="x0Input">Starting value (x‚ÇÄ):</label>
                <input type="number" id="x0Input" value="27" min="1" step="1">
                <button onclick="app.selectedRange = null; app.plotSequence()">Plot Sequence</button>
                <button onclick="app.clearCanvas()">Clear</button>
            </div>
            <div class="control-row">
                <label>Examples:</label>
                <button onclick="app.loadExample(27)">27</button>
                <button onclick="app.loadExample(31)">31</button>
                <button onclick="app.loadExample(63)">63</button>
                <button onclick="app.loadExample(127)">127</button>
                <button onclick="app.loadExample(70055)">70055</button>
                <button onclick="app.loadExample(77031)">77031</button>
            </div>
            <div class="control-row">
                <label>
                    <input type="checkbox" id="showEvenTerms" onchange="app.toggleEvenTerms()">
                    Show even terms on lattice
                </label>
            </div>
            <div class="control-row">
                <label>Layers:</label>
                <label><input type="checkbox" id="layerGrid" checked onchange="app.toggleLayer('Grid')"> Grid</label>
                <label><input type="checkbox" id="layerAxes" checked onchange="app.toggleLayer('Axes')"> Axes</label>
                <label><input type="checkbox" id="layerPath" checked onchange="app.toggleLayer('Path')"> Path</label>
                <label><input type="checkbox" id="layerBlocks" onchange="app.toggleLayer('OE Blocks')"> OE Blocks</label>
                <label><input type="checkbox" id="layerXValue" checked onchange="app.toggleLayer('X Values')"> Œª‚Çì-layer</label>
                <label><input type="checkbox" id="layerEpsilon" onchange="app.toggleLayer('Epsilon')"> Œµ-layer</label>
                <button id="animateButton" onclick="app.toggleAnimation()" style="margin-left: 20px;">Animate to Œª‚Çì</button>
            </div>
        </div>

        <div id="infoPanel" class="info-panel" style="display: none;">
            <div class="info-section">
                <div class="info-label">
                    Lattice Parameters
                    <span class="popout-icon" id="popoutParamsBtn" title="Pop out lattice parameters">‚ßâ</span>
                </div>
                <div class="info-value" id="infoContent"></div>
            </div>
        </div>

        <div id="compositeBlockPanel" class="info-panel" style="display: none;">
            <div class="info-section">
                <div class="info-label">Composite Block</div>
                <div class="info-value" id="compositeBlockContent"></div>
            </div>
        </div>

    </div>

    <script>
        // Configuration
        const CONFIG = {
            maxIterations: 10000,
            gridSize: 20,
            pointRadius: 4,
            lineWidth: 2,
            colors: {
                oddStep: '#ff6b6b',    // Red for O steps (3x+1)
                evenStep: '#4a9eff',   // Blue for E steps (x/2)
                grid: '#333',
                axes: '#666',
                point: '#fff',
                blocks: [
                    '#ff00ff',  // Magenta
                    '#00ffff',  // Cyan
                    '#ffff00',  // Yellow
                    '#00ff00',  // Green
                    '#ff8800',  // Orange
                    '#8800ff',  // Purple
                    '#ff0088',  // Pink
                    '#88ff00',  // Lime
                ]
            }
        };

        // Exact rational arithmetic using native BigInt
        class Rational {
            constructor(num, den = 1n) {
                if (typeof num === 'number') num = BigInt(num);
                if (typeof den === 'number') den = BigInt(den);
                if (den === 0n) throw new Error('Division by zero');
                if (den < 0n) { num = -num; den = -den; }
                const g = Rational.gcd(num < 0n ? -num : num, den);
                this.num = num / g;
                this.den = den / g;
            }

            static gcd(a, b) {
                while (b !== 0n) { [a, b] = [b, a % b]; }
                return a;
            }

            static fromInt(n) {
                return new Rational(BigInt(n), 1n);
            }

            static pow2(n) {
                return new Rational(1n << BigInt(n), 1n);
            }

            static pow3(n) {
                return new Rational(3n ** BigInt(n), 1n);
            }

            add(other) {
                return new Rational(
                    this.num * other.den + other.num * this.den,
                    this.den * other.den
                );
            }

            sub(other) {
                return new Rational(
                    this.num * other.den - other.num * this.den,
                    this.den * other.den
                );
            }

            mul(other) {
                return new Rational(this.num * other.num, this.den * other.den);
            }

            div(other) {
                return new Rational(this.num * other.den, this.den * other.num);
            }

            neg() {
                return new Rational(-this.num, this.den);
            }

            isInteger() {
                return this.den === 1n;
            }

            toNumber() {
                return Number(this.num) / Number(this.den);
            }

            toBigInt() {
                if (!this.isInteger()) throw new Error(`Not an integer: ${this}`);
                return this.num;
            }

            toString() {
                if (this.den === 1n) return this.num.toString();
                return `${this.num}/${this.den}`;
            }

            eq(other) { return this.num === other.num && this.den === other.den; }

            cmp(other) {
                const diff = this.num * other.den - other.num * this.den;
                return diff < 0n ? -1 : diff > 0n ? 1 : 0;
            }

            lt(other) { return this.cmp(other) < 0; }
            gt(other) { return this.cmp(other) > 0; }
        }

        Rational.ZERO = new Rational(0n);
        Rational.ONE = new Rational(1n);

        // BigInt 2-adic valuation
        function v2b(n) {
            if (n === 0n) return Infinity;
            let count = 0;
            while (n % 2n === 0n) { count++; n = n / 2n; }
            return count;
        }

        // BigInt 3-adic valuation
        function v3b(n) {
            if (n === 0n) return Infinity;
            let count = 0;
            while (n % 3n === 0n) { count++; n = n / 3n; }
            return count;
        }

        // Block decomposition: represents a block with parameters (Œ±, Œ≤, œÅ, œÜ, t)
        // where œÅ and œÜ are Rational for exact arithmetic.
        class Block {
            constructor(alpha, beta, rho, phi, t) {
                this.alpha = alpha;     // Number: odd step count
                this.beta = beta;       // Number: excess even step count
                this.rho = rho;         // Rational: residue parameter
                this.phi = phi;         // Rational: perturbation (0 for natural)
                this.t = t;             // Number: scaling parameter
            }

            // x = 2^Œ±(œÅ + t¬∑2^(Œ≤+1)) - œÜ - 1
            x() {
                return Rational.pow2(this.alpha)
                    .mul(this.rho.add(Rational.fromInt(this.t).mul(Rational.pow2(this.beta + 1))))
                    .sub(this.phi)
                    .sub(Rational.ONE);
            }

            // x‚Üí = (3^Œ±¬∑œÅ - 1)/2^Œ≤ + 2¬∑3^Œ±¬∑t
            succ() {
                const threeA = Rational.pow3(this.alpha);
                return threeA.mul(this.rho).sub(Rational.ONE)
                    .div(Rational.pow2(this.beta))
                    .add(new Rational(2n).mul(threeA).mul(Rational.fromInt(this.t)));
            }

            // k = 2^(Œ±+Œ≤)¬∑x‚Üí - 3^Œ±¬∑x
            k() {
                return Rational.pow2(this.alpha + this.beta).mul(this.succ())
                    .sub(Rational.pow3(this.alpha).mul(this.x()));
            }

            isNatural() { return this.phi.eq(Rational.ZERO); }
        }

        class NaturalBlock extends Block {
            constructor(alpha, beta, rho, t) {
                super(alpha, beta, Rational.fromInt(rho), Rational.ZERO, t);
            }
            isNatural() { return true; }
        }

        class CompositeBlock extends Block {
            constructor(head, tail) {
                const alphaC = head.alpha + tail.alpha;
                const betaC = head.beta + tail.beta;

                // œÜ_c = œÜ_1 + (2^(Œ±‚ÇÅ+Œ≤‚ÇÅ)/3^Œ±‚ÇÅ)¬∑œÜ‚ÇÇ + (2^(Œ±‚ÇÅ+Œ≤‚ÇÅ) - 2^Œ±‚ÇÅ)(3^Œ±‚ÇÇ - 2^Œ±‚ÇÇ)/3^Œ±_c
                const pow2ab1 = Rational.pow2(head.alpha + head.beta);
                const phiC = head.phi
                    .add(pow2ab1.div(Rational.pow3(head.alpha)).mul(tail.phi))
                    .add(pow2ab1.sub(Rational.pow2(head.alpha))
                        .mul(Rational.pow3(tail.alpha).sub(Rational.pow2(tail.alpha)))
                        .div(Rational.pow3(alphaC)));

                // tÃÇ‚ÇÅ = t‚ÇÅ mod 2^(Œ±‚ÇÇ+Œ≤‚ÇÇ)
                const tailModB = 1n << BigInt(tail.alpha + tail.beta);
                const headTB = BigInt(head.t);
                const t1HatB = ((headTB % tailModB) + tailModB) % tailModB;
                const tC = Number((headTB - t1HatB) / tailModB);
                const t1Hat = Number(t1HatB);

                // œÅ_c = (2^Œ±‚ÇÅ¬∑(œÅ‚ÇÅ + tÃÇ‚ÇÅ¬∑2^(Œ≤‚ÇÅ+1)) + œÜ_c - œÜ‚ÇÅ) / 2^Œ±_c
                const rhoC = Rational.pow2(head.alpha)
                    .mul(head.rho.add(Rational.fromInt(t1Hat).mul(Rational.pow2(head.beta + 1))))
                    .add(phiC)
                    .sub(head.phi)
                    .div(Rational.pow2(alphaC));

                super(alphaC, betaC, rhoC, phiC, tC);
                this.head = head;
                this.tail = tail;
            }
        }

        // Decompose odd x into a block (Œ±, Œ≤, œÅ, œÜ, t) encoding its trajectory to 1.
        // Returns a NaturalBlock if x‚Üí = 1, otherwise a CompositeBlock.
        function decomposeBlock(x) {
            const xB = typeof x === 'bigint' ? x : BigInt(x);
            const alpha = v2b(xB + 1n);
            const rhoBarB = (xB + 1n) / (1n << BigInt(alpha));
            const beta = v2b(3n ** BigInt(alpha) * rhoBarB - 1n);
            const modulusB = 1n << BigInt(beta + 1);
            const rhoB = rhoBarB % modulusB;
            const tB = (rhoBarB - rhoB) / modulusB;
            const xSuccB = (3n ** BigInt(alpha) * rhoBarB - 1n) / (1n << BigInt(beta));

            const rho = Number(rhoB);
            const t = Number(tB);

            if (xSuccB === 1n) {
                return new NaturalBlock(alpha, beta, rho, t);
            }
            return new CompositeBlock(
                new NaturalBlock(alpha, beta, rho, t),
                decomposeBlock(xSuccB)
            );
        }

        // Build the decomposition table: each row is the cumulative composite
        // from that level down to 1, plus the natural block at that level.
        // Returns array of { natural: NaturalBlock, composite: Block }
        function decompositionTable(x) {
            const rows = [];
            let block = decomposeBlock(x);
            while (true) {
                if (block instanceof CompositeBlock) {
                    rows.push({ natural: block.head, composite: block });
                    block = block.tail;
                } else {
                    // Final natural block (x‚Üí = 1)
                    rows.push({ natural: block, composite: block });
                    break;
                }
            }
            return rows;
        }

        // Compose natural blocks from x down to (but not including) succX.
        // Follows the decomposition chain: each call to decomposeBlock gives a
        // natural block head whose successor is the next x in the chain.
        function composeBlocksInRange(x, succX) {
            const xB = typeof x === 'bigint' ? x : BigInt(x);
            const succXB = typeof succX === 'bigint' ? succX : BigInt(succX);
            const naturals = [];
            let current = xB;
            while (current !== succXB && current > 1n) {
                const block = decomposeBlock(current);
                const head = (block instanceof CompositeBlock) ? block.head : block;
                naturals.push(head);
                current = head.succ().toBigInt();
            }
            if (naturals.length === 0) return null;
            if (naturals.length === 1) return naturals[0];
            let result = naturals[naturals.length - 1];
            for (let i = naturals.length - 2; i >= 0; i--) {
                result = new CompositeBlock(naturals[i], result);
            }
            return result;
        }

        // Collatz sequence computation with (o, e, r) tracking
        class CollatzSequence {
            constructor(x0) {
                this.x0 = BigInt(x0);
                this.steps = [];
                this.sortedByL = null;  // Sorted index for descent term search
                this._decomposition = null;  // Lazy block decomposition cache
                this.compute();
                this.buildLIndex();  // Build L-index after computing sequence
            }

            // Lazy accessor: block decomposition table for x0
            // Returns array of { natural: NaturalBlock, composite: Block }
            get decomposition() {
                if (!this._decomposition && this.x0 > 1n && this.x0 % 2n === 1n) {
                    this._decomposition = decompositionTable(this.x0);
                }
                return this._decomposition;
            }

            compute() {
                // First, compute the sequence forward to get x values and types
                // x values are BigInt throughout for exact arithmetic
                let x = this.x0;
                let tempSteps = [{ x: x, type: 'start' }];

                let iterations = 0;
                while (x !== 1n && iterations < CONFIG.maxIterations) {
                    if (x % 2n === 1n) {
                        // Odd step: 3x+1
                        x = 3n * x + 1n;
                        tempSteps.push({ x: x, type: 'O' });
                    } else {
                        // Even step: x/2
                        x = x / 2n;
                        tempSteps.push({ x: x, type: 'E' });
                    }
                    iterations++;
                }

                if (iterations >= CONFIG.maxIterations) {
                    throw new Error(`Sequence did not reach 1 within ${CONFIG.maxIterations} iterations`);
                }

                // Now compute o, e, r, Œ±, Œ≤, Œ≥ backwards from x=1 (where o=0, e=0)
                // Start from the end and work backwards
                for (let i = tempSteps.length - 1; i >= 0; i--) {
                    const currentX = tempSteps[i].x;

                    // Compute Œ± = v‚ÇÇ(x+1)
                    // currentX is already BigInt
                    tempSteps[i].alpha = v2b(currentX + 1n);

                    // Compute m = (x+1) / 2^Œ± (BigInt exact)
                    const mBig = (currentX + 1n) / (1n << BigInt(tempSteps[i].alpha));
                    tempSteps[i].m = Number(mBig);

                    // Compute Œ≤ = v‚ÇÇ(3^Œ± ¬∑ m - 1)
                    const threePowAlpha = 3n ** BigInt(tempSteps[i].alpha);
                    tempSteps[i].beta = v2b(threePowAlpha * mBig - 1n);

                    // Compute lambda_x = log_2(x)
                    tempSteps[i].lambda_x = Math.log2(Number(currentX));

                    if (i === tempSteps.length - 1) {
                        // At x=1: o=0, e=0
                        tempSteps[i].o = 0;
                        tempSteps[i].e = 0;
                        tempSteps[i].r = 0;
                        tempSteps[i].n = i;
                    } else {
                        // Get successor (next step in forward direction)
                        const successor = tempSteps[i + 1];

                        // If current x is odd, o = successor.o + 1, e = successor.e
                        // If current x is even, o = successor.o, e = successor.e + 1
                        if (currentX % 2n === 1n) {
                            tempSteps[i].o = successor.o + 1;
                            tempSteps[i].e = successor.e;
                        } else {
                            tempSteps[i].o = successor.o;
                            tempSteps[i].e = successor.e + 1;
                        }

                        tempSteps[i].r = 2 * tempSteps[i].o - tempSteps[i].e;
                        tempSteps[i].n = i;
                    }

                    // Compute d = 2^(2o-r) - 3^o (after o and r are set)
                    const oBig = BigInt(tempSteps[i].o);
                    const twoPowE = 1n << BigInt(tempSteps[i].e);
                    const threePowO = 3n ** oBig;
                    tempSteps[i].d_big = (1n << BigInt(2 * tempSteps[i].o - tempSteps[i].r)) - threePowO;
                    tempSteps[i].d = Number(tempSteps[i].d_big);

                    // Compute k = 2^e - 3^o * x (after o and e are set)
                    tempSteps[i].k_big = twoPowE - threePowO * currentX;
                    tempSteps[i].k = Number(tempSteps[i].k_big);

                    // Compute lambda_k = log_2(|k|)
                    const kAbs = tempSteps[i].k_big < 0n ? -tempSteps[i].k_big : tempSteps[i].k_big;
                    tempSteps[i].lambda_k = kAbs > 0n ? Math.log2(Number(kAbs)) : 0;

                    // For even x, compute ŒΩ = v‚ÇÇ(x) and work with odd part
                    // For odd x, ŒΩ = 0
                    // Simplified: x+1 = 2^ŒΩ ¬∑ 2^Œ± ¬∑ (œÅ + t¬∑2^(Œ∫-Œ±+1))
                    if (currentX % 2n === 0n) {
                        tempSteps[i].nu = v2b(currentX);
                        const xOddBig = currentX / (1n << BigInt(tempSteps[i].nu));
                        const alphaOdd = v2b(xOddBig + 1n);
                        const mOddBig = (xOddBig + 1n) / (1n << BigInt(alphaOdd));
                        const betaOdd = v2b(3n ** BigInt(alphaOdd) * mOddBig - 1n);
                        const modulusOdd = 1n << BigInt(betaOdd + 1);
                        tempSteps[i].rho = Number(mOddBig % modulusOdd);
                        tempSteps[i].t = Number((mOddBig - BigInt(tempSteps[i].rho)) / modulusOdd);
                    } else {
                        tempSteps[i].nu = 0;
                        const modBig = 1n << BigInt(tempSteps[i].beta + 1);
                        tempSteps[i].rho = Number(mBig % modBig);
                        tempSteps[i].t = Number((mBig - BigInt(tempSteps[i].rho)) / modBig);
                    }
                }

                this.steps = tempSteps;
            }

            buildLIndex() {
                // Build sorted index for efficient descent term search
                // Compute L for each step and create sorted array
                const theta = 2 - Math.log2(3);
                const normFactor = Math.sqrt(1 + theta * theta);

                // Create array of {step, L, o} tuples
                const indexEntries = this.steps.map(step => {
                    const c_or = theta * step.o - step.r;
                    const L = c_or / normFactor;
                    return { step, L, o: step.o };
                });

                // Sort by (L, o) ascending
                this.sortedByL = indexEntries.sort((a, b) => {
                    if (a.L !== b.L) return a.L - b.L;
                    return a.o - b.o;
                });
            }

            findFirstDescentTerm(searchStep) {
                // Find the first descent term where:
                // 1. x < x_search
                // 2. L < L_search
                // 3. o < o_search
                // Among all candidates, return the one with LARGEST o (closest to o_search from below)

                if (!this.sortedByL || this.sortedByL.length === 0) return null;

                const theta = 2 - Math.log2(3);
                const normFactor = Math.sqrt(1 + theta * theta);
                const c_or = theta * searchStep.o - searchStep.r;
                const searchL = c_or / normFactor;
                const searchO = searchStep.o;
                const searchX = searchStep.x;

                console.log(`Searching for descent term of x=${searchX}, o=${searchO}, L=${searchL.toFixed(3)}`);

                // Binary search to find the rightmost entry with L < searchL
                // This gives us the largest L that is still less than searchL
                let left = 0;
                let right = this.sortedByL.length - 1;
                let candidateIdx = -1;

                while (left <= right) {
                    const mid = Math.floor((left + right) / 2);

                    if (this.sortedByL[mid].L < searchL) {
                        // This could be a candidate, but check if there's a larger L < searchL
                        candidateIdx = mid;
                        left = mid + 1;  // Look for larger L values
                    } else {
                        right = mid - 1;  // L is too large, search left
                    }
                }

                // Now search backward from candidateIdx to find the best match
                // We want: L < searchL, o < searchO, x < searchX, and maximize o
                let bestCandidate = null;
                let bestO = -Infinity;

                // Search from candidateIdx backward (decreasing L)
                for (let i = candidateIdx; i >= 0; i--) {
                    const entry = this.sortedByL[i];

                    // Check all three conditions
                    if (entry.L < searchL && entry.o < searchO && entry.step.x < searchX) {
                        if (entry.o > bestO) {
                            bestO = entry.o;
                            bestCandidate = entry.step;
                        }
                    }
                }

                if (bestCandidate) {
                    const c_or_descent = theta * bestCandidate.o - bestCandidate.r;
                    const L_descent = c_or_descent / normFactor;
                    console.log(`  -> Found descent term: x=${bestCandidate.x}, o=${bestCandidate.o}, L=${L_descent.toFixed(3)}`);
                } else {
                    console.log(`  -> No descent term found (no step satisfying all conditions)`);
                }

                return bestCandidate;
            }

            // Compute block parameters for odd x (or odd core if x is even)
            // Returns { alpha, rho, beta, kappa, t, x_odd, rhoBar, xSucc, modulus }
            // Uses BigInt internally for exact arithmetic
            computeBlockParams(x) {
                // Step 1: Find odd value to analyze (odd core for even x)
                const xB = BigInt(x);
                const nu = v2b(xB);
                const x_odd = Number(xB / (1n << BigInt(nu)));

                // Step 2: Compute alpha and rhoBar from x_odd + 1
                const xOddB = BigInt(x_odd);
                const alpha = v2b(xOddB + 1n);
                const rhoBarB = (xOddB + 1n) / (1n << BigInt(alpha));

                // Step 3: Compute beta = v‚ÇÇ(3^Œ±¬∑œÅÃÑ - 1)
                const threePowA = 3n ** BigInt(alpha);
                const beta = v2b(threePowA * rhoBarB - 1n);
                const kappa = alpha + beta;

                // Step 4: Compute œÅ and t
                const modulusB = 1n << BigInt(beta + 1);
                const rhoB = rhoBarB % modulusB;
                const tB = (rhoBarB - rhoB) / modulusB;

                // Step 5: Compute x‚Üí (successor - first odd of next Steiner circuit)
                const xSuccB = (threePowA * rhoBarB - 1n) / (1n << BigInt(beta));

                return {
                    alpha, beta, kappa,
                    rho: Number(rhoB),
                    t: Number(tB),
                    modulus: Number(modulusB),
                    x_odd,
                    rhoBar: Number(rhoBarB),
                    xSucc: Number(xSuccB)
                };
            }

            getOEString() {
                return this.steps
                    .filter(s => s.type !== 'start')
                    .map(s => s.type)
                    .join('');
            }

            getBounds() {
                const oValues = this.steps.map(s => s.o);
                const rValues = this.steps.map(s => s.r);
                return {
                    minO: Math.min(...oValues),
                    maxO: Math.max(...oValues),
                    minR: Math.min(...rValues),
                    maxR: Math.max(...rValues)
                };
            }

            findOEBlocks() {
                // Find blocks matching ((OE)+E+) pattern
                const oeString = this.getOEString();
                const blocks = [];
                let i = 0;

                while (i < oeString.length) {
                    // Check if we're starting an (OE)+ sequence
                    if (i < oeString.length - 1 && oeString[i] === 'O' && oeString[i + 1] === 'E') {
                        const blockStart = i;

                        // Count (OE)+ pairs
                        while (i < oeString.length - 1 && oeString[i] === 'O' && oeString[i + 1] === 'E') {
                            i += 2;
                        }

                        // Mark where (OE)+ ends - this is the last E in the OE pairs
                        const oeEndIndex = i - 1;

                        // Check for E+ following the (OE)+ sequence
                        const eStart = i;
                        while (i < oeString.length && oeString[i] === 'E') {
                            i++;
                        }

                        // Only count as a block if we have at least one E after (OE)+
                        if (i > eStart) {
                            blocks.push({
                                start: blockStart,
                                end: i - 1,
                                oeEndIndex: oeEndIndex,  // Index of last E in (OE)+
                                pattern: oeString.substring(blockStart, i)
                            });
                        }
                    } else {
                        i++;
                    }
                }

                return blocks;
            }

            getAlphaBetaDistribution() {
                // Count occurrences of each (Œ≤, Œ±) pair for ODD x values only
                const counts = new Map();

                for (const step of this.steps) {
                    // Only include odd x values (matching Python: if s.x%2==1)
                    if (step.x % 2n === 1n) {
                        const key = `${step.beta},${step.alpha}`;
                        counts.set(key, (counts.get(key) || 0) + 1);
                    }
                }

                // Convert to array of {beta, alpha, count}
                const distribution = [];
                for (const [key, count] of counts.entries()) {
                    const [beta, alpha] = key.split(',').map(Number);
                    distribution.push({ beta, alpha, count });
                }

                return distribution;
            }

            getBlockForStep(stepIndex) {
                // Find which ((OE)+E+) block contains this step
                // A block with OE indices [start, end] includes:
                // - steps[start]: the starting odd term (before first transition)
                // - steps[start+1] through steps[end+1]: the transitions
                // So the block spans steps[start] through steps[end+1]

                const blocks = this.findOEBlocks();

                for (const block of blocks) {
                    // Check if stepIndex is within this block's range
                    if (stepIndex >= block.start && stepIndex <= block.end + 1) {
                        return block.pattern;
                    }
                }

                return null;
            }

            getOEBlockK(block) {
                // Get k value for OE block congruence
                // k = number of even terms in the block
                let k = 0;
                for (const char of block.pattern) {
                    if (char === 'E') k++;
                }
                return k;
            }

            getFirstDescentK(step) {
                // Get k value for first descent congruence
                // k = 2(o_x - o_fd) - (r_x - r_fd)
                const descentTerm = this.findFirstDescentTerm(step);
                if (!descentTerm) return null;

                const k = 2 * (step.o - descentTerm.o) - (step.r - descentTerm.r);
                return k;
            }

            getCongruences(x, k) {
                // Get congruence values x¬±2^k
                const xB = BigInt(x);
                const power = 1n << BigInt(k);
                const prev = xB - power;
                const next = xB + power;
                return {
                    prev: prev > 0n ? prev : null,
                    current: xB,
                    next: next,
                    k: k
                };
            }

            getOEPrefixWithKEvens(k) {
                // Extract OE prefix with exactly k E's from the sequence
                const oeString = this.getOEString();
                let evenCount = 0;
                let prefix = '';

                for (let i = 0; i < oeString.length; i++) {
                    prefix += oeString[i];
                    if (oeString[i] === 'E') {
                        evenCount++;
                        if (evenCount === k) {
                            break;
                        }
                    }
                }

                return prefix;
            }

            getLastEvenInOEPlusIndices() {
                // Returns step indices of the last even term in each (OE)+ sequence
                // These should be shown even when "Show even terms" is unchecked
                const blocks = this.findOEBlocks();
                const indices = [];

                for (const block of blocks) {
                    // oeEndIndex is the OE string index of the last E in (OE)+
                    // Convert to step index: oeEndIndex + 1 (since steps[0] is start)
                    const stepIndex = block.oeEndIndex + 1;
                    indices.push(stepIndex);
                }

                return indices;
            }
        }

        // Utility functions for congruence display

        // Format congruence display as clickable HTML for info panels
        function formatCongruenceHTML(congruences) {
            const { prev, current, next, k } = congruences;
            let parts = [`k=${k}:`];

            if (prev) {
                parts.push(`<a href="?x=${prev}" class="congruence-link">‚Üê</a>`);
                parts.push(`<a href="?x=${prev}" class="congruence-link">${prev}</a>`);
            }

            parts.push('|');
            parts.push(`<strong>${current}</strong>`);  // Current not linked
            parts.push('|');

            if (next) {
                parts.push(`<a href="?x=${next}" class="congruence-link">${next}</a>`);
                parts.push(`<a href="?x=${next}" class="congruence-link">‚Üí</a>`);
            }

            return parts.join(' ');
        }

        // Format congruence display as plain text for canvas tooltips
        function formatCongruenceText(congruences) {
            const { prev, current, next, k } = congruences;
            let parts = [`k=${k}:`];

            if (prev) parts.push(`‚Üê ${prev}`);
            parts.push(`| ${current} |`);
            if (next) parts.push(`${next} ‚Üí`);

            return parts.join(' ');
        }

        // Base Layer class for rendering system
        class Layer {
            constructor(name, enabled = true) {
                this.name = name;
                this.enabled = enabled;
                this.usesRightAxis = false;
                this.rightAxisLabel = '';
            }

            render(ctx, sequences, latticeTransform, rightAxisTransform = null) {
                // Override in subclasses
            }

            getRightAxisBounds(sequences) {
                // Override if usesRightAxis = true
                return null;
            }
        }

        // Grid layer - background grid lines
        class GridLayer extends Layer {
            constructor(enabled = true) {
                super('Grid', enabled);
            }

            render(ctx, sequences, latticeTransform) {
                if (sequences.length === 0) return;

                // Calculate bounds from visible steps
                let minO = Infinity, maxO = -Infinity;
                let minR = Infinity, maxR = -Infinity;

                for (const seq of sequences) {
                    const visibleSteps = latticeTransform.getVisibleSteps(seq);
                    for (const step of visibleSteps) {
                        minO = Math.min(minO, step.o);
                        maxO = Math.max(maxO, step.o);
                        minR = Math.min(minR, step.r);
                        maxR = Math.max(maxR, step.r);
                    }
                }

                minO = Math.floor(minO) - 2;
                maxO = Math.ceil(maxO) + 2;
                minR = Math.floor(minR) - 2;
                maxR = Math.ceil(maxR) + 2;

                ctx.strokeStyle = CONFIG.colors.grid;
                ctx.lineWidth = 0.5;

                // Vertical grid lines (constant o)
                for (let o = minO; o <= maxO; o++) {
                    const x = latticeTransform.toScreenX(o);
                    ctx.beginPath();
                    ctx.moveTo(x, latticeTransform.toScreenY(minR));
                    ctx.lineTo(x, latticeTransform.toScreenY(maxR));
                    ctx.stroke();
                }

                // Horizontal grid lines (constant r)
                for (let r = minR; r <= maxR; r++) {
                    const y = latticeTransform.toScreenY(r);
                    ctx.beginPath();
                    ctx.moveTo(latticeTransform.toScreenX(minO), y);
                    ctx.lineTo(latticeTransform.toScreenX(maxO), y);
                    ctx.stroke();
                }
            }
        }

        // Axes layer - O and R coordinate axes
        class AxesLayer extends Layer {
            constructor(enabled = true) {
                super('Axes', enabled);
            }

            render(ctx, sequences, latticeTransform) {
                if (sequences.length === 0) return;

                // Calculate bounds
                let minO = Infinity, maxO = -Infinity;
                let minR = Infinity, maxR = -Infinity;

                for (const seq of sequences) {
                    const visibleSteps = latticeTransform.getVisibleSteps(seq);
                    for (const step of visibleSteps) {
                        minO = Math.min(minO, step.o);
                        maxO = Math.max(maxO, step.o);
                        minR = Math.min(minR, step.r);
                        maxR = Math.max(maxR, step.r);
                    }
                }

                minO = Math.floor(minO) - 2;
                maxO = Math.ceil(maxO) + 2;
                minR = Math.floor(minR) - 2;
                maxR = Math.ceil(maxR) + 2;

                ctx.strokeStyle = CONFIG.colors.axes;
                ctx.lineWidth = 2;

                // O-axis (r = 0)
                if (minR <= 0 && maxR >= 0) {
                    const y = latticeTransform.toScreenY(0);
                    ctx.beginPath();
                    ctx.moveTo(latticeTransform.toScreenX(minO), y);
                    ctx.lineTo(latticeTransform.toScreenX(maxO), y);
                    ctx.stroke();
                }

                // R-axis (o = 0)
                if (minO <= 0 && maxO >= 0) {
                    const x = latticeTransform.toScreenX(0);
                    ctx.beginPath();
                    ctx.moveTo(x, latticeTransform.toScreenY(minR));
                    ctx.lineTo(x, latticeTransform.toScreenY(maxR));
                    ctx.stroke();
                }

                // Labels
                ctx.fillStyle = CONFIG.colors.axes;
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('o ‚Üí', latticeTransform.toScreenX(maxO) - 20, latticeTransform.toScreenY(0) - 10);
                ctx.save();
                ctx.translate(latticeTransform.toScreenX(0) + 20, latticeTransform.toScreenY(maxR) + 20);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('r ‚Üí', 0, 0);
                ctx.restore();
            }
        }

        // OE Blocks layer - ((OE)+E+) block visualization
        class OEBlocksLayer extends Layer {
            constructor(enabled = false) {
                super('OE Blocks', enabled);
            }

            render(ctx, sequences, latticeTransform) {
                for (const sequence of sequences) {
                    const blocks = sequence.findOEBlocks();

                    for (let blockIdx = 0; blockIdx < blocks.length; blockIdx++) {
                        const block = blocks[blockIdx];
                        const color = CONFIG.colors.blocks[blockIdx % CONFIG.colors.blocks.length];

                        const startStepIdx = block.start;
                        const endStepIdx = block.end + 1;
                        const blockSteps = sequence.steps.slice(startStepIdx, endStepIdx + 1);

                        if (blockSteps.length < 2) continue;

                        // Find bounding box
                        const oValues = blockSteps.map(s => s.o);
                        const rValues = blockSteps.map(s => s.r);
                        const minO = Math.min(...oValues);
                        const maxO = Math.max(...oValues);
                        const minR = Math.min(...rValues);
                        const maxR = Math.max(...rValues);

                        const padding = 10;
                        const x1 = latticeTransform.toScreenX(minO) - padding;
                        const y1 = latticeTransform.toScreenY(maxR) - padding;
                        const width = latticeTransform.toScreenX(maxO) - latticeTransform.toScreenX(minO) + padding * 2;
                        const height = latticeTransform.toScreenY(minR) - latticeTransform.toScreenY(maxR) + padding * 2;

                        // Draw semi-transparent box
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 3;
                        ctx.setLineDash([5, 5]);
                        ctx.strokeRect(x1, y1, width, height);
                        ctx.setLineDash([]);

                        ctx.fillStyle = color + '20';
                        ctx.fillRect(x1, y1, width, height);

                        // Label
                        ctx.fillStyle = color;
                        ctx.font = 'bold 12px sans-serif';
                        ctx.textAlign = 'left';
                        ctx.fillText(block.pattern, x1 + 5, y1 + 15);
                    }
                }
            }
        }

        // Path layer - sequence paths and points
        class PathLayer extends Layer {
            constructor(enabled = true) {
                super('Path', enabled);
            }

            render(ctx, sequences, latticeTransform) {
                const t = latticeTransform.animationT || 0;

                for (const sequence of sequences) {
                    // Get visible steps
                    const filteredSteps = latticeTransform.getVisibleSteps(sequence);

                    // Always draw original lattice at (o, r) in gold
                    // Draw edges
                    for (let i = 0; i < filteredSteps.length - 1; i++) {
                        const curr = filteredSteps[i];
                        const next = filteredSteps[i + 1];

                        const x1 = latticeTransform.toScreenX(curr.o);
                        const y1 = latticeTransform.toScreenY(curr.r);
                        const x2 = latticeTransform.toScreenX(next.o);
                        const y2 = latticeTransform.toScreenY(next.r);

                        ctx.strokeStyle = next.type === 'O' ? CONFIG.colors.oddStep : CONFIG.colors.evenStep;
                        ctx.lineWidth = CONFIG.lineWidth;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }

                    // Draw original points
                    for (let i = 0; i < filteredSteps.length; i++) {
                        const step = filteredSteps[i];
                        const x = latticeTransform.toScreenX(step.o);
                        const y = latticeTransform.toScreenY(step.r);

                        // Check if this step is the descent term - color it cyan
                        const isDescentTerm = latticeTransform.descentTerm && step.n === latticeTransform.descentTerm.n;
                        ctx.fillStyle = isDescentTerm ? 'rgba(0, 255, 255, 0.8)' : 'rgba(255, 215, 0, 0.6)';  // Cyan for descent, gold for others
                        ctx.beginPath();
                        ctx.arc(x, y, CONFIG.pointRadius, 0, 2 * Math.PI);
                        ctx.fill();

                        // Label start and end
                        if (i === 0 || i === filteredSteps.length - 1) {
                            ctx.fillStyle = '#fff';
                            ctx.font = 'bold 12px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.fillText(
                                i === 0 ? `Start (${step.x})` : `End (${step.x})`,
                                x,
                                y - 15
                            );
                        }
                    }

                    // If animating, draw animated copy morphing to (o, -log‚ÇÇ(x)) with color change
                    if (t > 0) {
                        // Interpolate color from gold to green
                        const r = Math.round(255 * (1 - t) + 50 * t);
                        const g = Math.round(215 * (1 - t) + 205 * t);
                        const b = Math.round(0 * (1 - t) + 50 * t);
                        const alpha = 0.6 * (1 - t) + 0.5 * t;

                        // Draw animated edges
                        for (let i = 0; i < filteredSteps.length - 1; i++) {
                            const curr = filteredSteps[i];
                            const next = filteredSteps[i + 1];

                            const x1 = latticeTransform.toScreenX(curr.o);
                            const y1 = latticeTransform.toScreenY(latticeTransform.getAnimatedY(curr));
                            const x2 = latticeTransform.toScreenX(next.o);
                            const y2 = latticeTransform.toScreenY(latticeTransform.getAnimatedY(next));

                            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                            ctx.lineWidth = CONFIG.lineWidth;

                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }

                        // Draw animated points
                        for (let i = 0; i < filteredSteps.length; i++) {
                            const step = filteredSteps[i];
                            const x = latticeTransform.toScreenX(step.o);
                            const y = latticeTransform.toScreenY(latticeTransform.getAnimatedY(step));

                            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                            ctx.beginPath();
                            ctx.arc(x, y, CONFIG.pointRadius, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                    }
                }
            }
        }

        // X Value layer - plots at (o, log‚ÇÇ(x)) on left axis with Œ≤ as circle size
        // Also draws mirrored plot at (o, -log‚ÇÇ(x)) with fixed size and lower intensity
        class XValueLayer extends Layer {
            constructor(enabled = true) {
                super('X Values', enabled);
                this.usesRightAxis = false;
            }

            render(ctx, sequences, latticeTransform, rightAxisTransform) {
                const theta = 2 - Math.log2(3);

                // Determine which step should have the horizontal line
                const highlightStep = latticeTransform.hoveredPoint
                    ? latticeTransform.hoveredPoint.step
                    : latticeTransform.defaultStep;

                // Draw horizontal reference lines on log‚ÇÇ(x) graph corresponding to theta-slope lines
                // These lines correspond to the three theta-slope lines on the o-r lattice
                if (highlightStep && sequences.length > 0) {
                    // Get bounds for drawing lines across the canvas
                    let minO = Infinity, maxO = -Infinity;
                    for (const seq of sequences) {
                        const visibleSteps = latticeTransform.getVisibleSteps(seq);
                        for (const step of visibleSteps) {
                            minO = Math.min(minO, step.o);
                            maxO = Math.max(maxO, step.o);
                        }
                    }
                    minO = Math.floor(minO) - 2;
                    maxO = Math.ceil(maxO) + 2;

                    // Line 1: Orange - corresponds to x-estimator on o-r lattice
                    // O-R lattice: r = Œ∏*o + c1, where c1 = r - Œ∏*o
                    // Log‚ÇÇ(x) graph: y = -c1 = Œ∏*o - r = c‚Çí,·µ£
                    const c_or = theta * highlightStep.o - highlightStep.r;
                    ctx.strokeStyle = 'rgba(255, 140, 0, 0.6)';  // Match orange theta line
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([6, 3]);
                    ctx.beginPath();
                    ctx.moveTo(latticeTransform.toScreenX(minO), latticeTransform.toScreenY(c_or));
                    ctx.lineTo(latticeTransform.toScreenX(maxO), latticeTransform.toScreenY(c_or));
                    ctx.stroke();

                    // Line 2: Red-orange - corresponds to (o,r)-estimator on o-r lattice
                    // O-R lattice: r = Œ∏*o + c2, where c2 = -log‚ÇÇ(x)
                    // Log‚ÇÇ(x) graph: y = -c2 = log‚ÇÇ(x) = c‚Çì
                    const c_x = Math.log2(Number(highlightStep.x));
                    ctx.strokeStyle = 'rgba(255, 69, 0, 0.6)';  // Match red-orange theta line
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(latticeTransform.toScreenX(minO), latticeTransform.toScreenY(c_x));
                    ctx.lineTo(latticeTransform.toScreenX(maxO), latticeTransform.toScreenY(c_x));
                    ctx.stroke();

                    // Line 3: Gray - corresponds to origin line on o-r lattice
                    // O-R lattice: r = Œ∏*o (c3 = 0)
                    // Log‚ÇÇ(x) graph: y = 0
                    ctx.strokeStyle = 'rgba(128, 128, 128, 0.5)';  // Match gray theta line
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(latticeTransform.toScreenX(minO), latticeTransform.toScreenY(0));
                    ctx.lineTo(latticeTransform.toScreenX(maxO), latticeTransform.toScreenY(0));
                    ctx.stroke();

                    // Reset line dash
                    ctx.setLineDash([]);
                }

                // Draw circle for highlighted step
                if (highlightStep) {
                    const o = highlightStep.o;
                    const r = highlightStep.r;
                    const logX = highlightStep.lambda_x;
                    const negLogX = -highlightStep.lambda_x;

                    // Draw connector lines: (0,-log‚ÇÇ(x)) ‚Üí (o,-log‚ÇÇ(x)) ‚Üí (o,r)
                    ctx.strokeStyle = 'rgba(50, 205, 50, 0.4)';  // Lower intensity green for mirror lines
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([4, 2]);

                    // Draw horizontal line from (0,-log‚ÇÇ(x)) to (o,-log‚ÇÇ(x))
                    ctx.beginPath();
                    ctx.moveTo(latticeTransform.toScreenX(0), latticeTransform.toScreenY(negLogX));
                    ctx.lineTo(latticeTransform.toScreenX(o), latticeTransform.toScreenY(negLogX));
                    ctx.stroke();

                    // Draw vertical line from (o,-log‚ÇÇ(x)) to (o,r)
                    ctx.beginPath();
                    ctx.moveTo(latticeTransform.toScreenX(o), latticeTransform.toScreenY(negLogX));
                    ctx.lineTo(latticeTransform.toScreenX(o), latticeTransform.toScreenY(r));
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw circle at highlighted point's mirrored lambda_x position (-log‚ÇÇ(x))
                    const xMirror = latticeTransform.toScreenX(o);
                    const yMirror = latticeTransform.toScreenY(negLogX);
                    const radiusMirror = 4;  // Fixed size for mirror

                    ctx.fillStyle = 'rgba(50, 205, 50, 0.3)';  // Lower intensity for mirror
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';  // Lower intensity stroke
                    ctx.lineWidth = 1;

                    ctx.beginPath();
                    ctx.arc(xMirror, yMirror, radiusMirror, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();

                    // Draw circle at highlighted point's lambda_x position
                    const x = latticeTransform.toScreenX(o);
                    const y = latticeTransform.toScreenY(logX);
                    const radius = highlightStep.beta + 3;

                    ctx.fillStyle = 'rgba(50, 205, 50, 0.5)';  // Semi-transparent green (lime green)
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';  // Semi-transparent black stroke
                    ctx.lineWidth = 1;

                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }

                // Draw circles only for visible steps (respects "show evens" toggle)
                for (const seq of sequences) {
                    const visibleSteps = latticeTransform.getVisibleSteps(seq);
                    for (const step of visibleSteps) {
                        const o = step.o;
                        const logX = step.lambda_x;

                        // Draw circle at x point
                        const x = latticeTransform.toScreenX(o);
                        const y = latticeTransform.toScreenY(logX);
                        const radius = step.beta + 3;

                        // Check if this step is the descent term - color it cyan
                        const isDescentTerm = latticeTransform.descentTerm && step.n === latticeTransform.descentTerm.n;
                        ctx.fillStyle = isDescentTerm ? 'rgba(0, 255, 255, 0.7)' : 'rgba(50, 205, 50, 0.5)';  // Cyan for descent, green for others
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';  // Semi-transparent black stroke
                        ctx.lineWidth = 1;

                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                    }
                }

                // Draw mirrored circles at -log‚ÇÇ(x) with fixed size and lower intensity
                for (const seq of sequences) {
                    const visibleSteps = latticeTransform.getVisibleSteps(seq);
                    for (const step of visibleSteps) {
                        const o = step.o;
                        const negLogX = -step.lambda_x;

                        // Draw mirrored circle
                        const x = latticeTransform.toScreenX(o);
                        const y = latticeTransform.toScreenY(negLogX);
                        const radius = 4;  // Fixed size

                        // Check if this step is the descent term - color it cyan
                        const isDescentTerm = latticeTransform.descentTerm && step.n === latticeTransform.descentTerm.n;
                        ctx.fillStyle = isDescentTerm ? 'rgba(0, 255, 255, 0.3)' : 'rgba(50, 205, 50, 0.2)';  // Cyan for descent, green for others
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';  // Lower intensity stroke
                        ctx.lineWidth = 1;

                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                    }
                }
            }
        }

        // Epsilon layer - plots Œµ = (c‚Çí,·µ£ - c‚Çì)/‚àö(1+Œ∏¬≤) on right axis
        class EpsilonLayer extends Layer {
            constructor(enabled = false) {
                super('Epsilon', enabled);
                this.usesRightAxis = true;
                this.rightAxisLabel = 'Œµ = (c‚Çí,·µ£ - c‚Çì)/‚àö(1+Œ∏¬≤)';
            }

            getRightAxisBounds(sequences) {
                const theta = 2 - Math.log2(3);
                const normFactor = Math.sqrt(1 + theta * theta);

                let minEpsilon = Infinity;
                let maxEpsilon = -Infinity;

                for (const seq of sequences) {
                    for (const step of seq.steps) {
                        if (step.x % 2n === 1n) {
                            const c_or = theta * step.o - step.r;
                            const c_x = Math.log2(Number(step.x));
                            const epsilon = (c_or - c_x) / normFactor;

                            minEpsilon = Math.min(minEpsilon, epsilon);
                            maxEpsilon = Math.max(maxEpsilon, epsilon);
                        }
                    }
                }

                return { min: minEpsilon, max: maxEpsilon };
            }

            render(ctx, sequences, latticeTransform, rightAxisTransform) {
                if (!rightAxisTransform) return;

                const theta = 2 - Math.log2(3);
                const normFactor = Math.sqrt(1 + theta * theta);

                for (const seq of sequences) {
                    for (const step of seq.steps) {
                        // Check if this step is the descent term
                        const isDescentTerm = latticeTransform.descentTerm && step.n === latticeTransform.descentTerm.n;

                        // Show odd x values OR descent term (even if even)
                        if (step.x % 2n === 1n || isDescentTerm) {
                            const c_or = theta * step.o - step.r;
                            const c_x = Math.log2(Number(step.x));
                            const epsilon = (c_or - c_x) / normFactor;

                            const x = latticeTransform.toScreenX(step.o);
                            const y = rightAxisTransform.toScreenY(epsilon);
                            const radius = 4; // Fixed size for epsilon points

                            ctx.fillStyle = isDescentTerm ? 'rgba(0, 255, 255, 0.7)' : 'rgba(255, 0, 255, 0.5)';  // Cyan for descent, magenta for others
                            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                            ctx.lineWidth = 1;

                            ctx.beginPath();
                            ctx.arc(x, y, radius, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.stroke();
                        }
                    }
                }
            }
        }

        // Canvas renderer for the O-R lattice
        class LatticeRenderer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.sequences = [];
                this.transform = {
                    offsetX: 0,
                    offsetY: 0,
                    scale: 1
                };
                this.hoveredPoint = null;
                this.descentTerm = null;  // Descent term for hovered point
                this.showEvenTerms = false; // Default to false - only show odd terms

                // Layer management
                this.layers = [];
                this.rightAxisLayers = [];
                this.rightAxisScale = null;

                // Animation state
                this.animationT = 0; // 0 = normal (o,r), 1 = transformed (o,-log‚ÇÇ(x))
                this.isAnimating = false;
                this.animationDirection = 1; // 1 = forward, -1 = backward

                // Tooltip positioning
                // null = auto (smart placement based on quadrant)
                // or one of: 'top-left', 'top-right', 'bottom-left', 'bottom-right'
                this.tooltipPosition = null;

                // Selection state for drag-to-select (horizontal bands)
                this.isSelecting = false;
                this.selectionStart = null;  // {x, y} screen coordinates
                this.selectionEnd = null;    // {x, y} screen coordinates
                this.selectionRect = null;   // {x, y, width, height}
                this.onSelectionComplete = null;  // Callback when selection completes

                // Selected block highlight range {minO, maxO} or null
                this.selectedBlockRange = null;

                this.initializeLayers();
                this.setupEventListeners();
            }

            initializeLayers() {
                // Add layers in rendering order
                this.addLayer(new GridLayer());
                this.addLayer(new AxesLayer());
                this.addLayer(new OEBlocksLayer());
                this.addLayer(new PathLayer());
                this.addLayer(new XValueLayer());

                // Right-axis layers
                this.addRightAxisLayer(new EpsilonLayer());
            }

            addLayer(layer) {
                this.layers.push(layer);
            }

            addRightAxisLayer(layer) {
                this.rightAxisLayers.push(layer);
            }

            findLayer(name) {
                // Search in both arrays
                let layer = this.layers.find(l => l.name === name);
                if (!layer) {
                    layer = this.rightAxisLayers.find(l => l.name === name);
                }
                return layer;
            }

            setupEventListeners() {
                // Mousedown - start selection
                this.canvas.addEventListener('mousedown', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    this.isSelecting = true;
                    this.selectionStart = { x: mouseX, y: mouseY };
                    this.selectionEnd = { x: mouseX, y: mouseY };
                    this.updateSelectionRect();
                });

                // Mouseup - complete selection
                this.canvas.addEventListener('mouseup', (e) => {
                    if (this.isSelecting) {
                        this.isSelecting = false;

                        // Only process if it was a real horizontal drag (not just a click)
                        if (this.selectionRect && this.selectionRect.width > 5) {
                            this.processSelection();
                        }

                        this.selectionRect = null;
                        this.selectionStart = null;
                        this.selectionEnd = null;
                        this.render();
                    }
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    // Handle selection drag
                    if (this.isSelecting) {
                        this.selectionEnd = { x: mouseX, y: mouseY };
                        this.updateSelectionRect();
                        this.render();
                        return; // Skip hover logic while selecting
                    }

                    const newHoveredPoint = this.findPointAtPosition(mouseX, mouseY);

                    // Reset tooltip position if we moved to a different point
                    if (!this.hoveredPoint || !newHoveredPoint ||
                        this.hoveredPoint.step.n !== newHoveredPoint.step.n) {
                        this.tooltipPosition = null;
                    }

                    this.hoveredPoint = newHoveredPoint;

                    // Compute descent term for hovered point
                    if (this.hoveredPoint && this.hoveredPoint.sequence) {
                        this.descentTerm = this.hoveredPoint.sequence.findFirstDescentTerm(this.hoveredPoint.step);
                    } else {
                        this.descentTerm = null;
                    }

                    this.render();
                });

                this.canvas.addEventListener('mouseleave', () => {
                    // Cancel selection if mouse leaves canvas
                    if (this.isSelecting) {
                        this.isSelecting = false;
                        this.selectionRect = null;
                        this.selectionStart = null;
                        this.selectionEnd = null;
                    }

                    this.hoveredPoint = null;
                    this.descentTerm = null;
                    this.tooltipPosition = null;
                    this.render();
                });

                this.canvas.addEventListener('dblclick', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    const point = this.findPointAtPosition(mouseX, mouseY);
                    if (point && this.onPointDoubleClick) {
                        this.onPointDoubleClick(point.step.x);
                    }
                });

                // Keyboard controls for tooltip positioning
                document.addEventListener('keydown', (e) => {
                    if (!this.hoveredPoint) return;

                    const key = e.key.toLowerCase();
                    if (!['u', 'l', 'd', 'r'].includes(key)) return;

                    e.preventDefault();

                    // Get current position (or auto-calculated position)
                    let currentPos = this.tooltipPosition || this.getAutoTooltipPosition(this.hoveredPoint);

                    // Move tooltip based on key
                    const [vertical, horizontal] = currentPos.split('-');
                    let newVertical = vertical;
                    let newHorizontal = horizontal;

                    if (key === 'u' && vertical === 'bottom') newVertical = 'top';
                    if (key === 'd' && vertical === 'top') newVertical = 'bottom';
                    if (key === 'l' && horizontal === 'right') newHorizontal = 'left';
                    if (key === 'r' && horizontal === 'left') newHorizontal = 'right';

                    this.tooltipPosition = `${newVertical}-${newHorizontal}`;
                    this.render();
                });
            }

            getAutoTooltipPosition(hoveredPoint) {
                // Determine tooltip position based on quadrant of hovered point
                // Place tooltip on opposite side to avoid obscuring the point
                const step = hoveredPoint.step;
                const x = this.toScreenX(step.o);
                const y = this.toScreenY(step.r);

                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;

                // Determine quadrant and place tooltip on opposite side
                const isLeft = x < centerX;
                const isTop = y < centerY;

                if (isTop && isLeft) {
                    return 'bottom-right';
                } else if (isTop && !isLeft) {
                    return 'bottom-left';
                } else if (!isTop && isLeft) {
                    return 'top-right';
                } else {
                    return 'top-left';
                }
            }

            startAnimation() {
                if (this.isAnimating) return;

                this.isAnimating = true;
                // Toggle direction based on current position
                if (this.animationT >= 1) {
                    this.animationDirection = -1; // Go back to normal
                } else if (this.animationT <= 0) {
                    this.animationDirection = 1; // Go to lambda_x
                }

                this.animateStep();
            }

            animateStep() {
                if (!this.isAnimating) return;

                const duration = 1500; // 1.5 seconds
                const deltaT = (this.animationDirection * 16) / duration; // Approx 16ms per frame

                this.animationT += deltaT;

                // Clamp and stop at bounds
                if (this.animationT >= 1) {
                    this.animationT = 1;
                    this.isAnimating = false;
                } else if (this.animationT <= 0) {
                    this.animationT = 0;
                    this.isAnimating = false;
                }

                // Apply easing (smooth start and stop)
                const t = this.animationT;
                const easedT = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

                this.currentEasedT = easedT;
                this.render();

                if (this.isAnimating) {
                    requestAnimationFrame(() => this.animateStep());
                } else {
                    // Animation completed, update button text
                    if (this.onAnimationComplete) {
                        this.onAnimationComplete();
                    }
                }
            }

            getAnimatedY(step) {
                // Interpolate between r and log‚ÇÇ(x)
                const t = this.currentEasedT || 0;
                return (1 - t) * step.r + t * step.lambda_x;
            }

            findPointAtPosition(mouseX, mouseY) {
                const hoverRadius = 10; // pixels

                for (const seq of this.sequences) {
                    const visibleSteps = this.getVisibleSteps(seq);

                    for (const step of visibleSteps) {
                        const x = this.toScreenX(step.o);
                        const y = this.toScreenY(step.r);
                        const dx = mouseX - x;
                        const dy = mouseY - y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance <= hoverRadius) {
                            // Return both step and sequence
                            return { step, sequence: seq };
                        }
                    }
                }
                return null;
            }

            // Selection helper methods
            updateSelectionRect() {
                if (!this.selectionStart || !this.selectionEnd) {
                    this.selectionRect = null;
                    return;
                }

                const x = Math.min(this.selectionStart.x, this.selectionEnd.x);
                const y = Math.min(this.selectionStart.y, this.selectionEnd.y);
                const width = Math.abs(this.selectionEnd.x - this.selectionStart.x);
                const height = Math.abs(this.selectionEnd.y - this.selectionStart.y);

                this.selectionRect = { x, y, width, height };
            }

            findPointsInSelection() {
                if (!this.selectionRect) return [];

                const { x, width } = this.selectionRect;
                const points = [];

                for (const seq of this.sequences) {
                    const visibleSteps = this.getVisibleSteps(seq);

                    for (const step of visibleSteps) {
                        const screenX = this.toScreenX(step.o);

                        // Check if point is within horizontal selection range
                        if (screenX >= x && screenX <= x + width) {
                            points.push({ step, sequence: seq });
                        }
                    }
                }

                return points;
            }

            processSelection() {
                if (!this.selectionRect) return;
                if (this.sequences.length === 0) return;

                const sequence = this.sequences[0];
                const { x, width } = this.selectionRect;
                // Inset edges by half a grid unit to avoid picking up adjacent points
                const halfGrid = this.transform.scale * 0.5;
                const leftEdge = x + halfGrid;
                const rightEdge = x + width - halfGrid;

                // Find all odd terms inside the selection, track leftmost and rightmost by o
                let leftOdd = null, rightOdd = null;
                let minO = Infinity, maxO = -Infinity;

                for (const step of sequence.steps) {
                    if (step.x % 2n !== 1n) continue;

                    const screenX = this.toScreenX(step.o);

                    if (screenX >= leftEdge && screenX <= rightEdge) {
                        if (step.o < minO) {
                            minO = step.o;
                            leftOdd = step.x;
                        }
                        if (step.o > maxO) {
                            maxO = step.o;
                            rightOdd = step.x;
                        }
                    }
                }

                if (rightOdd === null) return;

                // Trigger callback with range
                if (this.onSelectionComplete) {
                    this.onSelectionComplete(leftOdd, rightOdd);
                }
            }

            drawSelectionRect() {
                if (!this.selectionRect) return;

                const { x, width } = this.selectionRect;

                // Draw horizontal band (full canvas height)
                this.ctx.fillStyle = 'rgba(74, 158, 255, 0.2)';
                this.ctx.fillRect(x, 0, width, this.canvas.height);

                // Draw vertical lines at edges
                this.ctx.strokeStyle = 'rgba(74, 158, 255, 0.8)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 3]);
                this.ctx.beginPath();
                this.ctx.moveTo(x, 0);
                this.ctx.lineTo(x, this.canvas.height);
                this.ctx.moveTo(x + width, 0);
                this.ctx.lineTo(x + width, this.canvas.height);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }

            drawSelectedBlockRange() {
                if (!this.selectedBlockRange) return;

                const { minO, maxO } = this.selectedBlockRange;

                // Offset boundaries by 1/3 of a grid square
                // Left boundary: 1/3 square to the LEFT of minO
                // Right boundary: 1/3 square to the RIGHT of maxO
                const offset = this.transform.scale / 3;
                const leftX = this.toScreenX(minO) - offset;
                const rightX = this.toScreenX(maxO) + offset;
                const width = rightX - leftX;

                // Draw semi-transparent highlight band
                this.ctx.fillStyle = 'rgba(74, 158, 255, 0.15)';
                this.ctx.fillRect(leftX, 0, width, this.canvas.height);

                // Draw solid vertical lines at edges
                this.ctx.strokeStyle = 'rgba(74, 158, 255, 0.5)';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([]);
                this.ctx.beginPath();
                this.ctx.moveTo(leftX, 0);
                this.ctx.lineTo(leftX, this.canvas.height);
                this.ctx.moveTo(rightX, 0);
                this.ctx.lineTo(rightX, this.canvas.height);
                this.ctx.stroke();
            }

            getVisibleSteps(sequence) {
                // Returns steps that should be visible based on showEvenTerms setting
                if (this.showEvenTerms) {
                    return sequence.steps;
                } else {
                    // Show odd x, start, last even in each (OE)+ sequence, and descent term (always visible)
                    const lastEvenIndices = new Set(sequence.getLastEvenInOEPlusIndices());
                    return sequence.steps.filter((s, idx) =>
                        s.x % 2n === 1n ||
                        s.type === 'start' ||
                        lastEvenIndices.has(idx) ||
                        (this.descentTerm && s.n === this.descentTerm.n)  // Always show descent term
                    );
                }
            }

            clear() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.sequences = [];
            }

            addSequence(sequence) {
                this.sequences.push(sequence);
                this.fitToView();
                this.render();
            }

            fitToView() {
                if (this.sequences.length === 0) return;

                // Get combined bounds from visible steps
                let minO = Infinity, maxO = -Infinity;
                let minR = Infinity, maxR = -Infinity;

                for (const seq of this.sequences) {
                    const visibleSteps = this.getVisibleSteps(seq);

                    for (const step of visibleSteps) {
                        minO = Math.min(minO, step.o);
                        maxO = Math.max(maxO, step.o);
                        minR = Math.min(minR, step.r);
                        maxR = Math.max(maxR, step.r);

                        // Also consider lambda_x values for viewport bounds (both positive and negative)
                        const logX = step.lambda_x;
                        minR = Math.min(minR, logX, -logX);
                        maxR = Math.max(maxR, logX, -logX);
                    }
                }

                // Add padding
                const padding = 2;
                minO -= padding;
                maxO += padding;
                minR -= padding;
                maxR += padding;

                // Calculate scale to fit
                const rangeO = maxO - minO;
                const rangeR = maxR - minR;
                const scaleO = (this.canvas.width - 100) / rangeO;
                const scaleR = (this.canvas.height - 100) / rangeR;
                this.transform.scale = Math.min(scaleO, scaleR, CONFIG.gridSize);

                // Center the view
                this.transform.offsetX = 50 - minO * this.transform.scale;
                this.transform.offsetY = this.canvas.height - 50 + minR * this.transform.scale;
            }

            toScreenX(o) {
                return this.transform.offsetX + o * this.transform.scale;
            }

            toScreenY(r) {
                return this.transform.offsetY - r * this.transform.scale;
            }

            calculateRightAxisScale() {
                // Calculate bounds for all enabled right-axis layers
                let minValue = Infinity;
                let maxValue = -Infinity;
                let hasEnabledLayers = false;

                for (const layer of this.rightAxisLayers) {
                    if (layer.enabled) {
                        const bounds = layer.getRightAxisBounds(this.sequences);
                        if (bounds) {
                            minValue = Math.min(minValue, bounds.min);
                            maxValue = Math.max(maxValue, bounds.max);
                            hasEnabledLayers = true;
                        }
                    }
                }

                if (!hasEnabledLayers) {
                    this.rightAxisScale = null;
                    return;
                }

                // Add some padding
                const range = maxValue - minValue;
                const padding = range * 0.1;
                minValue -= padding;
                maxValue += padding;

                this.rightAxisScale = {
                    min: minValue,
                    max: maxValue,
                    range: maxValue - minValue
                };
            }

            drawRightAxis() {
                if (!this.rightAxisScale) return;

                // Calculate right axis position (right edge of canvas with margin)
                const margin = 80;
                const axisX = this.canvas.width - margin;

                // Get canvas bounds in screen coordinates
                const topY = 50;
                const bottomY = this.canvas.height - 50;

                // Helper to convert value to screen Y
                const valueToScreenY = (value) => {
                    const normalized = (value - this.rightAxisScale.min) / this.rightAxisScale.range;
                    return bottomY - normalized * (bottomY - topY);
                };

                // Draw axis line
                this.ctx.strokeStyle = CONFIG.colors.axes;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(axisX, topY);
                this.ctx.lineTo(axisX, bottomY);
                this.ctx.stroke();

                // Draw tick marks and labels
                this.ctx.fillStyle = '#e0e0e0';  // Brighter tick text
                this.ctx.font = '12px sans-serif';
                this.ctx.textAlign = 'left';
                this.ctx.textBaseline = 'middle';

                // Calculate nice tick intervals
                const numTicks = 5;
                const tickStep = this.rightAxisScale.range / numTicks;

                for (let i = 0; i <= numTicks; i++) {
                    const value = this.rightAxisScale.min + i * tickStep;
                    const y = valueToScreenY(value);

                    // Tick mark
                    this.ctx.strokeStyle = CONFIG.colors.axes;
                    this.ctx.beginPath();
                    this.ctx.moveTo(axisX - 5, y);
                    this.ctx.lineTo(axisX + 5, y);
                    this.ctx.stroke();

                    // Label
                    this.ctx.fillText(value.toFixed(1), axisX + 10, y);
                }

                // Draw Œª‚Çò = 0 line if 0 is within range
                if (this.rightAxisScale.min <= 0 && this.rightAxisScale.max >= 0) {
                    const zeroY = valueToScreenY(0);
                    this.ctx.strokeStyle = '#888';
                    this.ctx.lineWidth = 1;
                    this.ctx.setLineDash([5, 3]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(50, zeroY);
                    this.ctx.lineTo(this.canvas.width - margin, zeroY);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }

                // Draw axis labels for enabled layers
                const enabledLabels = this.rightAxisLayers
                    .filter(l => l.enabled && l.rightAxisLabel)
                    .map(l => l.rightAxisLabel);

                if (enabledLabels.length > 0) {
                    this.ctx.save();
                    this.ctx.translate(this.canvas.width - 20, (topY + bottomY) / 2);
                    this.ctx.rotate(-Math.PI / 2);
                    this.ctx.textAlign = 'center';
                    this.ctx.fillStyle = '#e0e0e0';  // Brighter axis label
                    this.ctx.fillText(enabledLabels.join(', '), 0, 0);
                    this.ctx.restore();
                }
            }

            render() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Calculate right axis bounds from enabled layers
                this.calculateRightAxisScale();

                // Create lattice transform object for layers
                const latticeTransform = {
                    toScreenX: this.toScreenX.bind(this),
                    toScreenY: this.toScreenY.bind(this),
                    getVisibleSteps: this.getVisibleSteps.bind(this),
                    hoveredPoint: this.hoveredPoint,
                    descentTerm: this.descentTerm,  // Pass descent term to layers
                    defaultStep: this.sequences.length > 0 ? this.sequences[0].steps[0] : null,
                    getAnimatedY: this.getAnimatedY.bind(this),
                    animationT: this.currentEasedT || 0
                };

                // Create right axis transform if needed
                let rightAxisTransform = null;
                if (this.rightAxisScale) {
                    const margin = 80;
                    const axisX = this.canvas.width - margin;
                    const topY = 50;
                    const bottomY = this.canvas.height - 50;

                    rightAxisTransform = {
                        toScreenX: this.toScreenX.bind(this),
                        toScreenY: (value) => {
                            const normalized = (value - this.rightAxisScale.min) / this.rightAxisScale.range;
                            return bottomY - normalized * (bottomY - topY);
                        }
                    };
                }

                // Render regular layers
                for (const layer of this.layers) {
                    if (layer.enabled) {
                        layer.render(this.ctx, this.sequences, latticeTransform);
                    }
                }

                // Draw right axis
                this.drawRightAxis();

                // Render right-axis layers
                for (const layer of this.rightAxisLayers) {
                    if (layer.enabled) {
                        layer.render(this.ctx, this.sequences, latticeTransform, rightAxisTransform);
                    }
                }

                // Draw theta reference lines
                this.drawThetaLines();

                // Draw lambda_x reference line
                this.drawLambdaXLine(rightAxisTransform);

                // Draw selected block highlight (persistent)
                this.drawSelectedBlockRange();

                // Draw selection rectangle if selecting
                if (this.isSelecting && this.selectionRect) {
                    this.drawSelectionRect();
                }

                // Draw tooltip last (on top)
                if (this.hoveredPoint) {
                    this.drawTooltip(this.hoveredPoint);
                }
            }

            drawThetaLines() {
                if (this.sequences.length === 0) return;

                // Calculate theta = 2 - log_2(3)
                const theta = 2 - Math.log2(3);

                // Determine which point to use for reference
                let refStep;
                if (this.hoveredPoint) {
                    refStep = this.hoveredPoint.step;
                } else {
                    // Use the first step (x0) of the first sequence
                    refStep = this.sequences[0].steps[0];
                }

                // Get bounds for drawing lines across the canvas
                let minO = Infinity, maxO = -Infinity;
                for (const seq of this.sequences) {
                    const visibleSteps = this.getVisibleSteps(seq);
                    for (const step of visibleSteps) {
                        minO = Math.min(minO, step.o);
                        maxO = Math.max(maxO, step.o);
                    }
                }
                minO = Math.floor(minO) - 2;
                maxO = Math.ceil(maxO) + 2;

                // Line 1: x-estimator - passes through (o_ref, r_ref)
                // Given (o,r), estimates x from r-axis intercept
                const c1 = refStep.r - theta * refStep.o;
                const r1_start = theta * minO + c1;
                const r1_end = theta * maxO + c1;

                this.ctx.strokeStyle = 'rgba(255, 140, 0, 0.6)';  // Semi-transparent orange
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([6, 3]);
                this.ctx.beginPath();
                this.ctx.moveTo(this.toScreenX(minO), this.toScreenY(r1_start));
                this.ctx.lineTo(this.toScreenX(maxO), this.toScreenY(r1_end));
                this.ctx.stroke();

                // Line 2: (o,r)-estimator - passes through (0, -log_2(x_ref))
                // Given x, estimates where (o,r) should fall
                const c2 = -Math.log2(Number(refStep.x));
                const r2_start = theta * minO + c2;
                const r2_end = theta * maxO + c2;

                this.ctx.strokeStyle = 'rgba(255, 69, 0, 0.6)';  // Semi-transparent red-orange
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([3, 3]);
                this.ctx.beginPath();
                this.ctx.moveTo(this.toScreenX(minO), this.toScreenY(r2_start));
                this.ctx.lineTo(this.toScreenX(maxO), this.toScreenY(r2_end));
                this.ctx.stroke();

                // Line 3: Passes through origin (0, 0)
                // r = theta * o (intercept = 0)
                const r3_start = theta * minO;
                const r3_end = theta * maxO;

                this.ctx.strokeStyle = 'rgba(128, 128, 128, 0.5)';  // Semi-transparent gray
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([2, 2]);
                this.ctx.beginPath();
                this.ctx.moveTo(this.toScreenX(minO), this.toScreenY(r3_start));
                this.ctx.lineTo(this.toScreenX(maxO), this.toScreenY(r3_end));
                this.ctx.stroke();

                // Reset line dash
                this.ctx.setLineDash([]);
            }

            drawLambdaXLine(rightAxisTransform) {
                if (!rightAxisTransform || this.sequences.length === 0) return;

                // Find the XValueLayer to check orientation setting
                const xValueLayer = this.rightAxisLayers.find(l => l instanceof XValueLayer);
                if (!xValueLayer) return;

                const flipOrientation = xValueLayer.flipOrientation;
                let value;

                // Use hovered point if available, otherwise use initial x0
                if (this.hoveredPoint) {
                    value = flipOrientation ? -this.hoveredPoint.step.lambda_x : this.hoveredPoint.step.lambda_x;
                } else {
                    // Use the first step (x0) of the first sequence
                    value = flipOrientation ? -this.sequences[0].steps[0].lambda_x : this.sequences[0].steps[0].lambda_x;
                }

                const y = rightAxisTransform.toScreenY(value);
                const margin = 80;

                // Draw horizontal line across canvas at lambda_x (or -lambda_x)
                this.ctx.strokeStyle = 'rgba(68, 200, 255, 0.7)';  // Cyan to match X layer
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([8, 4]);
                this.ctx.beginPath();
                this.ctx.moveTo(50, y);
                this.ctx.lineTo(this.canvas.width - margin, y);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }

            drawTooltip(hoveredPoint) {
                const step = hoveredPoint.step;
                const sequence = hoveredPoint.sequence;

                const x = this.toScreenX(step.o);
                const y = this.toScreenY(step.r);

                // Highlight the hovered point
                this.ctx.fillStyle = '#ffff00';
                this.ctx.beginPath();
                this.ctx.arc(x, y, CONFIG.pointRadius + 2, 0, 2 * Math.PI);
                this.ctx.fill();

                // Find which block this step belongs to
                const stepIndex = step.n;
                const blockPattern = sequence.getBlockForStep(stepIndex);

                const lines = [];

                // Optional block pattern at top
                if (blockPattern) {
                    lines.push(blockPattern);
                    lines.push('');
                }

                // SECTION 1: Selected Block Panel (static version)
                lines.push('--- Selected Block ---');

                // Block Parameters (derived from odd core)
                const stepXB = step.x;
                const nu = v2b(stepXB);
                const x_oddB = step.x % 2n === 0n ? stepXB / (1n << BigInt(nu)) : stepXB;
                const x_odd = Number(x_oddB);
                const alpha_odd = v2b(x_oddB + 1n);
                const rhoBar_oddB = (x_oddB + 1n) / (1n << BigInt(alpha_odd));
                const rhoBar_odd = Number(rhoBar_oddB);
                const beta_odd = v2b(3n ** BigInt(alpha_odd) * rhoBar_oddB - 1n);
                const kappa = alpha_odd + beta_odd;
                const modulusB = 1n << BigInt(beta_odd + 1);
                const modulus = Number(modulusB);
                const rho_odd = Number(rhoBar_oddB % modulusB);
                const t_odd = Number((rhoBar_oddB - BigInt(rho_odd)) / modulusB);
                const xSucc = Number((3n ** BigInt(alpha_odd) * rhoBar_oddB - 1n) / (1n << BigInt(beta_odd)));

                // x and x‚Üí first
                if (step.x % 2n === 0n) {
                    lines.push(`x = 2^ŒΩ¬∑(2^Œ±(œÅ + t¬∑2^(Œ≤+1)) - 1) = ${step.x}`);
                } else {
                    lines.push(`x = 2^Œ±(œÅ + t¬∑2^(Œ≤+1)) - 1 = ${step.x}`);
                }
                lines.push(`x‚Üí = ${xSucc}`);
                lines.push('');

                // Block parameters
                if (step.x % 2n === 0n) {
                    lines.push(`ŒΩ=${nu}, Œ±=${alpha_odd}, Œ≤=${beta_odd}, œÅ=${rho_odd}, t=${t_odd}`);
                } else {
                    lines.push(`Œ±=${alpha_odd}, Œ≤=${beta_odd}, œÅ=${rho_odd}, t=${t_odd}`);
                }
                lines.push(`Œ∫ = Œ± + Œ≤ = ${kappa}`);

                // SECTION 2: Lattice Parameters
                lines.push('--- Lattice Parameters ---');
                const n_tooltip = 3 * step.o - step.r;
                lines.push(`o = ${step.o}`);
                lines.push(`r = ${step.r}`);
                lines.push(`e = 2o - r = ${step.e}`);
                lines.push(`n = 3o - r = o + e = ${n_tooltip}`);
                lines.push('');

                // Natural block equation
                if (step.x % 2n === 1n && step.x > 1n) {
                    const params_tt = this.sequences[0].computeBlockParams(step.x);
                    const m_x_tt = 1n << BigInt(params_tt.alpha + params_tt.beta + 1);
                    const c_x_tt = (1n << BigInt(params_tt.alpha)) * BigInt(params_tt.rho) - 1n;
                    lines.push(`x = 2^Œ±(œÅ + t¬∑2^(Œ≤+1)) - 1 = ${m_x_tt}t + ${c_x_tt} = ${step.x}`);
                    lines.push('');
                }

                // First descent term
                if (this.descentTerm) {
                    lines.push(`x‚Ççfd‚Çé = ${this.descentTerm.x}`);
                } else {
                    lines.push(`x‚Ççfd‚Çé = none`);
                }
                lines.push('');

                // Lambda values
                lines.push(`Œª‚Çì = log‚ÇÇ(x) = ${step.lambda_x.toFixed(3)}`);
                lines.push(`Œª‚Çñ = log‚ÇÇ(k) = ${step.lambda_k.toFixed(3)}`);
                lines.push('');

                // Unique derived parameters
                lines.push(`d = 2^(2o-r) - 3^o = ${step.d_big}`);
                lines.push(`k = 2^e - 3^o¬∑x = ${step.k_big}`);
                lines.push('');

                // Theta-line intercepts and distances
                const theta = 2 - Math.log2(3);
                const c_or = theta * step.o - step.r;
                const c_x = Math.log2(Number(step.x));
                const normFactor = Math.sqrt(1 + theta * theta);
                const L = c_or / normFactor;
                const epsilon = (c_or - c_x) / normFactor;

                lines.push(`Œ∏ = 2 - log‚ÇÇ(3) = ${theta.toFixed(4)}`);
                lines.push(`c‚Çí,·µ£ = Œ∏¬∑o - r = ${c_or.toFixed(3)}`);
                lines.push(`c‚Çì = log‚ÇÇ(x) = ${c_x.toFixed(3)}`);
                lines.push(`L = c‚Çí,·µ£/‚àö(1+Œ∏¬≤) = ${L.toFixed(3)}`);
                lines.push(`Œµ = (c‚Çí,·µ£-c‚Çì)/‚àö(1+Œ∏¬≤) = ${epsilon.toFixed(3)}`)

                this.ctx.font = '14px monospace';
                const padding = 10;
                const lineHeight = 18;

                // Calculate box dimensions
                let boxWidth = 0;
                for (const line of lines) {
                    const metrics = this.ctx.measureText(line);
                    boxWidth = Math.max(boxWidth, metrics.width);
                }
                boxWidth += padding * 2;
                const boxHeight = lines.length * lineHeight + padding * 2;

                // Determine tooltip position: use manual override or auto-calculate based on quadrant
                const position = this.tooltipPosition || this.getAutoTooltipPosition(hoveredPoint);
                const [vertical, horizontal] = position.split('-');

                const margin = 10;
                let tooltipX, tooltipY;

                // Position based on vertical/horizontal components
                if (horizontal === 'left') {
                    tooltipX = margin;
                } else {
                    tooltipX = this.canvas.width - boxWidth - margin;
                }

                if (vertical === 'top') {
                    tooltipY = margin;
                } else {
                    tooltipY = this.canvas.height - boxHeight - margin;
                }

                // Draw box background
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                this.ctx.fillRect(tooltipX, tooltipY, boxWidth, boxHeight);

                // Draw box border
                this.ctx.strokeStyle = '#ffff00';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(tooltipX, tooltipY, boxWidth, boxHeight);

                // Draw text lines
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = '14px monospace';
                this.ctx.textAlign = 'left';
                this.ctx.textBaseline = 'top';

                let currentY = tooltipY + padding;
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];

                    // Center the block pattern if it exists (first line)
                    if (i === 0 && blockPattern) {
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(line, tooltipX + boxWidth / 2, currentY);
                        this.ctx.textAlign = 'left';
                    } else if (line.includes('x‚Ççfd‚Çé')) {
                        // Special handling for x with subscript fd
                        // Parse: "x‚Ççfd‚Çé = value" -> draw x normally, fd as subscript, then " = value"
                        const parts = line.split('x‚Ççfd‚Çé');
                        let x = tooltipX + padding;

                        // Draw prefix (usually empty)
                        if (parts[0]) {
                            this.ctx.fillText(parts[0], x, currentY);
                            x += this.ctx.measureText(parts[0]).width;
                        }

                        // Draw 'x' in normal font
                        this.ctx.font = '14px monospace';
                        this.ctx.fillText('x', x, currentY);
                        x += this.ctx.measureText('x').width;

                        // Draw 'fd' as subscript (smaller font, offset down)
                        this.ctx.font = '10px monospace';
                        this.ctx.fillText('fd', x, currentY + 6);  // Offset down by 6px
                        x += this.ctx.measureText('fd').width;

                        // Draw rest of line (e.g., " = 40")
                        this.ctx.font = '14px monospace';
                        if (parts[1]) {
                            this.ctx.fillText(parts[1], x, currentY);
                        }
                    } else {
                        this.ctx.fillText(line, tooltipX + padding, currentY);
                    }

                    currentY += lineHeight;
                }
            }
        }

        // Main application
        class Application {
            constructor() {
                this.renderer = new LatticeRenderer('latticeCanvas');
                this.currentSequence = null;
                this.selectedRange = null;  // { leftX, rightX } range of odd x values (null = use x0)
                this.selectionSucc = null;  // x‚Üí of the composite block (for URL persistence)
                this.isInitialLoad = true;

                // Set up double-click handler
                this.renderer.onPointDoubleClick = (x) => {
                    this.loadSequenceForX(x);
                };

                // Set up animation complete handler
                this.renderer.onAnimationComplete = () => {
                    this.updateAnimateButton();
                };

                // Set up selection complete handler
                // Swipe sets selected range without changing x0
                this.renderer.onSelectionComplete = (leftX, rightX) => {
                    this.setSelectedRange(leftX, rightX);
                };

                // Handle browser back/forward buttons
                window.addEventListener('popstate', (e) => {
                    // Get x and succ from state or URL
                    let x, succ = null;
                    const urlParams = new URLSearchParams(window.location.search);
                    if (e.state && e.state.x) {
                        try { x = BigInt(e.state.x); } catch (err) { x = 27n; }
                        if (e.state.succ) {
                            try { succ = BigInt(e.state.succ); } catch (err) {}
                        }
                    } else {
                        const xParam = urlParams.get('x');
                        try { x = xParam ? BigInt(xParam) : 27n; } catch (err) { x = 27n; }
                        const succParam = urlParams.get('succ');
                        if (succParam) {
                            try { succ = BigInt(succParam); } catch (err) {}
                        }
                    }

                    document.getElementById('x0Input').value = x.toString();
                    this.isInitialLoad = true;
                    this.selectedRange = null;
                    this.plotSequence();
                    this.isInitialLoad = false;

                    // Restore selection from succ
                    if (succ !== null) {
                        this.restoreSelectionFromSucc(x, succ);
                    }
                });

                // Set up congruence link navigation
                this.setupCongruenceNavigation();

                // Handle popout window close events
                window.addEventListener('message', (event) => {
                    if (event.data.type === 'popoutClosed') {
                        if (event.data.name === 'lattice') {
                            document.querySelector('.canvas-container').style.display = 'block';
                            this.latticePopout = null;
                        } else if (event.data.name === 'controls') {
                            document.querySelector('.controls').style.display = 'block';
                            this.controlsPopout = null;
                        } else if (event.data.name === 'selectedBlock') {
                            // Only show if there's content to display
                            const selectedBlockSection = document.getElementById('selectedBlockSection');
                            const selectedBlockContent = document.getElementById('selectedBlockContent');
                            if (selectedBlockContent && selectedBlockContent.innerHTML.trim() !== '') {
                                selectedBlockSection.style.display = 'block';
                            }
                            this.selectedBlockPopout = null;
                        } else if (event.data.name === 'latticeParameters') {
                            // Only show if there's content to display
                            const infoPanel = document.getElementById('infoPanel');
                            const infoContent = document.getElementById('infoContent');
                            if (infoContent && infoContent.innerHTML.trim() !== '') {
                                infoPanel.style.display = 'block';
                            }
                            this.latticeParametersPopout = null;
                        }
                    }
                });

                this.loadFromURL();
            }

            loadFromURL() {
                // Read x and succ from query string
                const urlParams = new URLSearchParams(window.location.search);
                const xParam = urlParams.get('x');
                const succParam = urlParams.get('succ');

                if (xParam) {
                    try {
                        const x = BigInt(xParam);
                        if (x > 0n) {
                            document.getElementById('x0Input').value = x.toString();
                        }
                    } catch (e) {
                        // ignore invalid x parameter
                    }
                }

                // Defer selection restore until after plotSequence runs
                if (succParam) {
                    this._pendingSucc = succParam;
                }
            }

            setupCongruenceNavigation() {
                // Delegate click handler for congruence links
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('congruence-link')) {
                        e.preventDefault();
                        const href = e.target.getAttribute('href');

                        // Parse x from URL
                        const url = new URL(href, window.location.origin);
                        try {
                            const x = BigInt(url.searchParams.get('x'));
                            this.loadSequenceForX(x);
                        } catch (e) {
                            // ignore invalid values
                        }
                    }
                });
            }

            updateURL(x) {
                // Update URL without reloading the page, storing state for back button
                const url = new URL(window.location);
                url.searchParams.set('x', x);
                url.searchParams.delete('anchor_k'); // Clean up legacy parameter

                // Persist selection as succ parameter (the successor of the composite block)
                if (this.selectedRange) {
                    url.searchParams.set('succ', this.selectionSucc || '');
                } else {
                    url.searchParams.delete('succ');
                }

                const state = { x: x.toString(), succ: this.selectionSucc || null };

                if (this.isInitialLoad) {
                    // Replace state on initial load to avoid creating extra history entry
                    window.history.replaceState(state, '', url);
                } else {
                    // Push new state for user-initiated changes
                    window.history.pushState(state, '', url);
                }
            }

            showError(message) {
                const errorPanel = document.getElementById('errorPanel');
                errorPanel.textContent = message;
                errorPanel.style.display = 'block';
                setTimeout(() => {
                    errorPanel.style.display = 'none';
                }, 5000);
            }

            updateInfo(sequence) {
                document.getElementById('oeSequence').textContent = sequence.getOEString();

                // Update x‚ÇÄ info panel
                this.updateX0Info(sequence);

                // Update composite block panel
                this.updateCompositeBlockInfo(sequence);

                // Verify invariants
                this.verifyInvariants(sequence);
            }

            updateX0Info(sequence) {
                const step = sequence.steps[0]; // x‚ÇÄ
                const theta = 2 - Math.log2(3);
                const c_or = theta * step.o - step.r;
                const c_x = Math.log2(Number(step.x));
                const normFactor = Math.sqrt(1 + theta * theta);
                const L = c_or / normFactor;
                const epsilon = (c_or - c_x) / normFactor;

                const lines = [];

                // Lattice position (same format as tooltip)
                const n = 3 * step.o - step.r;
                lines.push(`o = ${step.o}`);
                lines.push(`r = ${step.r}`);
                lines.push(`e = 2o - r = ${step.e}`);
                lines.push(`n = 3o - r = o + e = ${n}`);
                lines.push(''); // Blank line

                // Natural block equation for x‚ÇÄ
                if (step.x % 2n === 1n && step.x > 1n) {
                    const params = sequence.computeBlockParams(step.x);
                    const m_x_b = 1n << BigInt(params.alpha + params.beta + 1);
                    const c_x_b = (1n << BigInt(params.alpha)) * BigInt(params.rho) - 1n;
                    lines.push(`x = 2<sup>Œ±</sup>(œÅ + t¬∑2<sup>Œ≤+1</sup>) - 1 = ${m_x_b}t + ${c_x_b} = ${step.x}`);
                    lines.push(''); // Blank line
                }

                // First descent term
                const descentTerm = sequence.findFirstDescentTerm(step);
                if (descentTerm) {
                    lines.push(`x<sub>fd</sub> = ${descentTerm.x}`);

                    // Add congruence navigation for x_fd
                    const k = sequence.getFirstDescentK(step);
                    if (k !== null) {
                        const congruences = sequence.getCongruences(step.x, k);
                        const congLine = formatCongruenceHTML(congruences);
                        lines.push(`&nbsp;&nbsp;${congLine}`);
                    }
                } else {
                    lines.push(`x<sub>fd</sub> = none`);
                }
                lines.push(''); // Blank line

                // Lambda values
                lines.push(`Œª‚Çì = log‚ÇÇ(x) = ${step.lambda_x.toFixed(3)}`);
                lines.push(`Œª‚Çñ = log‚ÇÇ(k) = ${step.lambda_k.toFixed(3)}`);
                lines.push(''); // Blank line

                // Unique derived parameters
                lines.push(`d = 2^(2o-r) - 3^o = ${step.d_big}`);
                lines.push(`k = 2^e - 3^o¬∑x = ${step.k_big}`);
                lines.push(''); // Blank line

                // Theta-line intercepts and distances
                lines.push(`Œ∏ = 2 - log‚ÇÇ(3) = ${theta.toFixed(4)}`);
                lines.push(`c‚Çí,·µ£ = Œ∏¬∑o - r = ${c_or.toFixed(3)}`);
                lines.push(`c‚Çì = log‚ÇÇ(x) = ${c_x.toFixed(3)}`);
                lines.push(`L = c‚Çí,·µ£/‚àö(1+Œ∏¬≤) = ${L.toFixed(3)}`);
                lines.push(`Œµ = (c‚Çí,·µ£-c‚Çì)/‚àö(1+Œ∏¬≤) = ${epsilon.toFixed(3)}`)

                // Use innerHTML instead of textContent to render HTML tags like <sub>
                document.getElementById('infoContent').innerHTML = lines.join('<br>');
                document.getElementById('infoPanel').style.display = 'block';

                // Update popout window if open
                if (this.latticeParametersPopout && !this.latticeParametersPopout.closed) {
                    this.latticeParametersPopout.postMessage({
                        type: 'updateLatticeParameters',
                        content: document.getElementById('infoPanel').innerHTML
                    }, '*');
                }
            }

            updateCompositeBlockInfo(sequence) {
                const panel = document.getElementById('compositeBlockPanel');
                const content = document.getElementById('compositeBlockContent');

                // Only show for odd x‚ÇÄ > 1
                if (sequence.x0 <= 1n || sequence.x0 % 2n === 0n) {
                    panel.style.display = 'none';
                    return;
                }

                const decomp = sequence.decomposition;
                if (!decomp || decomp.length === 0) {
                    panel.style.display = 'none';
                    return;
                }

                const block = decomp[0].composite;
                const lines = [];

                // Affine equations with symbolic, slope-intercept, and numeric forms
                const m_x = Rational.pow2(block.alpha + block.beta + 1);
                const c_x = Rational.pow2(block.alpha).mul(block.rho)
                    .sub(block.phi).sub(Rational.ONE);
                const threeA = Rational.pow3(block.alpha);
                const m_succ = new Rational(2n).mul(threeA);
                const c_succ = threeA.mul(block.rho).sub(Rational.ONE)
                    .div(Rational.pow2(block.beta));

                lines.push(`x = 2<sup>Œ±</sup>(œÅ + t¬∑2<sup>Œ≤+1</sup>) - œÜ - 1 = ${m_x}t + ${c_x} = ${block.x()}`);
                lines.push(`x<sup>‚Üí</sup> = (3<sup>Œ±</sup>œÅ - 1)/2<sup>Œ≤</sup> + 2¬∑3<sup>Œ±</sup>¬∑t = ${m_succ}t + ${c_succ} = ${block.succ()}`);
                lines.push('');

                lines.push(`Œ± = ${block.alpha}`);
                lines.push(`Œ≤ = ${block.beta}`);
                lines.push(`œÅ = ${block.rho}`);
                lines.push(`œÜ = ${block.phi}`);
                lines.push(`t = <input type="number" id="compositeBlockTSpinner" value="${block.t}" min="0" step="1" style="width: 60px;">`);
                lines.push(`Œ∫ = Œ± + Œ≤ = ${block.alpha + block.beta}`);

                content.innerHTML = lines.join('<br>');
                panel.style.display = 'block';

                // Attach t-spinner handler
                setTimeout(() => {
                    const tSpinner = document.getElementById('compositeBlockTSpinner');
                    if (tSpinner) {
                        tSpinner.addEventListener('change', () => {
                            const newT = parseInt(tSpinner.value);
                            if (!isNaN(newT) && newT >= 0) {
                                // Recompute x from composite block affine equation:
                                // x = 2^Œ±(œÅ + t¬∑2^(Œ≤+1)) - œÜ - 1
                                const tRat = Rational.fromInt(newT);
                                const newX = Rational.pow2(block.alpha)
                                    .mul(block.rho.add(tRat.mul(Rational.pow2(block.beta + 1))))
                                    .sub(block.phi)
                                    .sub(Rational.ONE);
                                if (newX.isInteger()) {
                                    this.loadSequenceForX(newX.toBigInt());
                                }
                            }
                        });
                    }
                }, 0);
            }

            verifyInvariants(sequence) {
                const distribution = sequence.getAlphaBetaDistribution();
                const finalStep = sequence.steps[0]; // Initial step has the final o, r values

                // Invariant 1: sum(count for cells where Œ±=1) should equal o
                let sumAlpha1 = 0;
                for (const point of distribution) {
                    if (point.alpha === 1) {
                        sumAlpha1 += point.count;
                    }
                }

                // Invariant 2: sum(count * (Œ±-2) for cells where Œ≤=1) should equal r
                let sumBeta1 = 0;
                for (const point of distribution) {
                    if (point.beta === 1) {
                        sumBeta1 += point.count * (point.alpha - 2);
                    }
                }

                console.log('=== Invariant Check ===');
                console.log(`x0 = ${sequence.x0}`);
                console.log(`Final o = ${finalStep.o}, r = ${finalStep.r}`);
                console.log(`Invariant 1: sum(count for Œ±=1) = ${sumAlpha1}, expected o = ${finalStep.o}, ‚úì=${sumAlpha1 === finalStep.o}`);
                console.log(`Invariant 2: sum(count * (Œ±-2) for Œ≤=1) = ${sumBeta1}, expected r = ${finalStep.r}, ‚úì=${sumBeta1 === finalStep.r}`);
                console.log('Distribution:', distribution);
            }

            plotSequence() {
                try {
                    let x0;
                    try {
                        x0 = BigInt(document.getElementById('x0Input').value);
                    } catch (e) {
                        x0 = -1n;
                    }
                    if (x0 < 1n) {
                        this.showError('Please enter a valid positive integer');
                        return;
                    }

                    const sequence = new CollatzSequence(x0);
                    this.currentSequence = sequence;
                    this.renderer.clear();
                    this.renderer.addSequence(sequence);
                    this.updateCanvasPopout();
                    this.updateInfo(sequence);

                    // Restore pending selection from URL succ parameter
                    if (this._pendingSucc) {
                        try {
                            this.restoreSelectionFromSucc(x0, BigInt(this._pendingSucc));
                        } catch (e) {}
                        this._pendingSucc = null;
                    }

                    // Update selected block section display
                    this.updateSelectedBlockSection();

                    // Update URL (after selection is set, so succ is included)
                    this.updateURL(x0);

                } catch (error) {
                    this.showError(error.message);
                    console.error(error);
                }
            }

            updateSelectedBlockSection() {
                const section = document.getElementById('selectedBlockSection');

                if (!this.currentSequence) {
                    section.style.display = 'none';
                    this.renderer.selectedBlockRange = null;
                    this.renderer.render();
                    return;
                }

                section.style.display = 'block';

                const x0 = this.currentSequence.steps[0].x;
                const range = this.selectedRange;
                const steps = this.currentSequence.steps;

                // Determine the start x and successor for the block range
                let blockXBig, blockSuccBig;
                let compositeBlock;

                if (range !== null) {
                    // Selection: compose blocks from rightX (highest o) down to leftX's successor
                    const leftStep = steps.find(s => s.x === range.leftX);
                    const rightStep = steps.find(s => s.x === range.rightX);

                    if (!leftStep || !rightStep) {
                        this.renderer.selectedBlockRange = null;
                        this.renderer.render();
                        return;
                    }

                    // rightX has highest o = start of composite, leftX has lowest o
                    // The successor is the decomposition successor of leftX's natural block
                    blockXBig = range.rightX;
                    const leftHead = decomposeBlock(range.leftX);
                    const leftNat = (leftHead instanceof CompositeBlock) ? leftHead.head : leftHead;
                    blockSuccBig = leftNat.succ().toBigInt();

                    compositeBlock = composeBlocksInRange(blockXBig, blockSuccBig);
                } else {
                    // Default: full composite block for x‚ÇÄ (all blocks down to 1)
                    if (x0 % 2n === 0n || x0 <= 1n) {
                        const firstOdd = steps.find(s => s.x % 2n === 1n);
                        if (!firstOdd) {
                            this.renderer.selectedBlockRange = null;
                            this.renderer.render();
                            return;
                        }
                        blockXBig = firstOdd.x;
                        blockSuccBig = 1n;
                        compositeBlock = composeBlocksInRange(blockXBig, 1n);
                    } else {
                        blockXBig = x0;
                        blockSuccBig = 1n;
                        const decomp = this.currentSequence.decomposition;
                        compositeBlock = decomp ? decomp[0].composite : composeBlocksInRange(x0, 1n);
                    }
                }

                if (!compositeBlock) {
                    this.renderer.selectedBlockRange = null;
                    this.renderer.render();
                    return;
                }

                // Track successor for URL persistence
                this.selectionSucc = range !== null ? blockSuccBig.toString() : null;

                // Build OE pattern by walking the decomposition chain
                let prefix = '';
                let walkX = blockXBig;
                while (walkX !== blockSuccBig && walkX > 1n) {
                    const block = decomposeBlock(walkX);
                    const head = (block instanceof CompositeBlock) ? block.head : block;
                    const seq = new CollatzSequence(walkX);
                    prefix += seq.getOEPrefixWithKEvens(head.alpha + head.beta);
                    walkX = head.succ().toBigInt();
                }
                document.getElementById('selectedBlockPattern').textContent = prefix;

                const lines = [];

                // Compute affine slopes and intercepts
                // x(t) = 2^Œ±(œÅ + t¬∑2^(Œ≤+1)) - œÜ - 1 = m_x¬∑t + c_x
                const m_x = Rational.pow2(compositeBlock.alpha + compositeBlock.beta + 1);
                const c_x = Rational.pow2(compositeBlock.alpha).mul(compositeBlock.rho)
                    .sub(compositeBlock.phi).sub(Rational.ONE);
                // x‚Üí(t) = (3^Œ±¬∑œÅ - 1)/2^Œ≤ + 2¬∑3^Œ±¬∑t = m_succ¬∑t + c_succ
                const threeA = Rational.pow3(compositeBlock.alpha);
                const m_succ = new Rational(2n).mul(threeA);
                const c_succ = threeA.mul(compositeBlock.rho).sub(Rational.ONE)
                    .div(Rational.pow2(compositeBlock.beta));

                // x and x‚Üí with symbolic and numeric forms
                lines.push(`x = 2<sup>Œ±</sup>(œÅ + t¬∑2<sup>Œ≤+1</sup>) - œÜ - 1 = ${m_x}t + ${c_x} = ${blockXBig}`);
                const xSuccDisplay = `<a href="#" class="succ-x-link" data-x="${blockSuccBig}">${blockSuccBig}</a>`;
                lines.push(`x<sup>‚Üí</sup> = (3<sup>Œ±</sup>œÅ - 1)/2<sup>Œ≤</sup> + 2¬∑3<sup>Œ±</sup>¬∑t = ${m_succ}t + ${c_succ} = ${xSuccDisplay}`);
                lines.push('');

                // Block Parameters
                lines.push(`Œ± = ${compositeBlock.alpha}`);
                lines.push(`Œ≤ = ${compositeBlock.beta}`);
                lines.push(`œÅ = ${compositeBlock.rho}`);
                lines.push(`œÜ = ${compositeBlock.phi}`);
                lines.push(`t = <input type="number" id="selectedBlockTSpinner" value="${compositeBlock.t}" min="0" step="1" style="width: 60px;">`);
                lines.push(`Œ∫ = Œ± + Œ≤ = ${compositeBlock.alpha + compositeBlock.beta}`);

                document.getElementById('selectedBlockContent').innerHTML = lines.join('<br>');

                // Set up event handlers (wrap in setTimeout to ensure DOM is updated)
                const capturedBlock = compositeBlock;
                setTimeout(() => {
                    const tSpinner = document.getElementById('selectedBlockTSpinner');
                    const succXLink = document.querySelector('.succ-x-link');

                    if (tSpinner) {
                        tSpinner.addEventListener('change', () => {
                            const newT = parseInt(tSpinner.value);
                            if (!isNaN(newT) && newT >= 0) {
                                // Recompute x from the composite block's affine equation
                                // x = 2^Œ±(œÅ + t¬∑2^(Œ≤+1)) - œÜ - 1
                                const newX = Rational.pow2(capturedBlock.alpha)
                                    .mul(capturedBlock.rho.add(Rational.fromInt(newT).mul(Rational.pow2(capturedBlock.beta + 1))))
                                    .sub(capturedBlock.phi)
                                    .sub(Rational.ONE);
                                if (!newX.isInteger()) return;
                                const newXBig = newX.toBigInt();
                                if (newXBig < 1n) return;

                                // Compute the translated successor
                                // x‚Üí = (3^Œ±¬∑œÅ - 1)/2^Œ≤ + 2¬∑3^Œ±¬∑t
                                const threeA = Rational.pow3(capturedBlock.alpha);
                                const newSucc = threeA.mul(capturedBlock.rho).sub(Rational.ONE)
                                    .div(Rational.pow2(capturedBlock.beta))
                                    .add(new Rational(2n).mul(threeA).mul(Rational.fromInt(newT)));
                                const newSuccBig = newSucc.isInteger() ? newSucc.toBigInt() : null;

                                // Load new sequence and restore selection before
                                // updateSelectedBlockSection runs (avoids double-render)
                                document.getElementById('x0Input').value = newXBig.toString();
                                const seq = new CollatzSequence(newXBig);
                                this.currentSequence = seq;
                                this.renderer.clear();
                                this.renderer.addSequence(seq);
                                this.updateCanvasPopout();
                                this.updateInfo(seq);

                                // Set selection range before rendering the block section
                                if (newSuccBig !== null) {
                                    this.restoreSelectionFromSucc(newXBig, newSuccBig);
                                }
                                if (!this.selectedRange) {
                                    this.selectedRange = { leftX: newXBig, rightX: newXBig };
                                }

                                this.updateSelectedBlockSection();
                                this.updateURL(newXBig);
                            }
                        });
                    }

                    // Set up event handler for x‚Üí link
                    if (succXLink) {
                        succXLink.addEventListener('click', (e) => {
                            e.preventDefault();
                            try {
                                const newX = BigInt(succXLink.dataset.x);
                                this.setSelectedX(newX);
                            } catch (e) { /* ignore invalid */ }
                        });
                    }
                }, 0);

                // Update block highlight on the lattice
                // The composite block spans Œ± total odd steps ending at the start x
                const startStep = steps.find(s => s.x === blockXBig);
                const highlightMaxO = startStep ? startStep.o : 0;
                const highlightMinO = highlightMaxO - compositeBlock.alpha;
                this.renderer.selectedBlockRange = { minO: highlightMinO, maxO: highlightMaxO };
                this.renderer.render();

                // Update popout window if open
                if (this.selectedBlockPopout && !this.selectedBlockPopout.closed) {
                    this.selectedBlockPopout.postMessage({
                        type: 'updateSelectedBlock',
                        content: document.getElementById('selectedBlockSection').innerHTML
                    }, '*');
                }
            }

            loadSequenceForX(x) {
                // Called when navigating to a different x value
                // x can be Number or BigInt
                this.selectedRange = null;
                document.getElementById('x0Input').value = x.toString();
                this.plotSequence();
            }

            setSelectedRange(leftX, rightX) {
                // Set the selected block range to display without changing x0
                this.selectedRange = { leftX, rightX };
                this.updateSelectedBlockSection();
                // Update URL to include succ parameter
                if (this.currentSequence) {
                    this.updateURL(this.currentSequence.steps[0].x);
                }
            }

            setSelectedX(x) {
                // Shorthand: select a single block
                this.setSelectedRange(x, x);
            }

            restoreSelectionFromSucc(x0Big, succBig) {
                // Restore a selection range from x‚ÇÄ down to (but not including) succ
                if (!this.currentSequence) return;
                const steps = this.currentSequence.steps;
                const x0Step = steps.find(s => s.x === x0Big);
                const succStep = steps.find(s => s.x === succBig);
                if (!x0Step || !succStep) return;
                const oddInRange = steps
                    .filter(s => s.x % 2n === 1n && s.o > succStep.o && s.o <= x0Step.o)
                    .sort((a, b) => a.o - b.o);
                if (oddInRange.length > 0) {
                    this.selectedRange = {
                        leftX: oddInRange[0].x,
                        rightX: oddInRange[oddInRange.length - 1].x
                    };
                }
            }

            clearCanvas() {
                this.renderer.clear();
                this.renderer.selectedBlockRange = null;
                this.currentSequence = null;
                this.selectedRange = null;
                document.getElementById('oeSequence').textContent = '-';
                document.getElementById('oeBlocks').textContent = '-';
                document.getElementById('infoPanel').style.display = 'none';
                document.getElementById('selectedBlockSection').style.display = 'none';
            }

            loadExample(x0) {
                this.selectedRange = null;  // Reset selection when loading example
                document.getElementById('x0Input').value = x0;
                this.plotSequence();
            }

            toggleEvenTerms() {
                const showEven = document.getElementById('showEvenTerms').checked;
                this.renderer.showEvenTerms = showEven;
                this.renderer.fitToView();
                this.renderer.render();
                this.updateCanvasPopout();
            }

            toggleLayer(layerName) {
                const layer = this.renderer.findLayer(layerName);
                if (layer) {
                    layer.enabled = !layer.enabled;
                    this.renderer.render();
                    this.updateCanvasPopout();
                    this.updateAnimateButton();
                }
            }

            toggleAnimation() {
                this.renderer.startAnimation();
            }

            updateCanvasPopout() {
                // Update lattice popout window if open
                if (this.latticePopout && !this.latticePopout.closed) {
                    this.latticePopout.postMessage({ type: 'updateCanvas' }, '*');
                }
            }

            updateAnimateButton() {
                const xValueLayer = this.renderer.findLayer('X Values');
                const button = document.getElementById('animateButton');

                if (xValueLayer && xValueLayer.enabled) {
                    button.style.display = 'inline-block';
                    // Update button text based on animation state
                    if (this.renderer.animationT >= 1) {
                        button.textContent = 'Animate to (o,r)';
                    } else {
                        button.textContent = 'Animate to Œª‚Çì';
                    }
                } else {
                    button.style.display = 'none';
                }
            }

            popoutLattice() {
                // Check if already popped out
                if (this.latticePopout && !this.latticePopout.closed) {
                    this.latticePopout.focus();
                    return;
                }

                const win = window.open('about:blank', 'Lattice', 'popup=yes,width=1250,height=900,left=100,top=100,resizable=yes,scrollbars=no');
                if (!win) return;

                // Hide the canvas container in main window
                document.querySelector('.canvas-container').style.display = 'none';

                win.document.write(`
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>O-R Lattice</title>
                        <style>
                            body { margin: 0; padding: 10px; background: #0f0f0f; }
                            canvas { display: block; background: #1a1a1a; border-radius: 4px; }
                        </style>
                    </head>
                    <body>
                        <canvas id="popoutCanvas" width="1200" height="800"></canvas>
                        <script>
                            // Copy canvas content from parent
                            const parentCanvas = window.opener.document.getElementById('latticeCanvas');
                            const canvas = document.getElementById('popoutCanvas');
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(parentCanvas, 0, 0);

                            // Listen for updates from parent
                            window.addEventListener('message', (event) => {
                                if (event.data.type === 'updateCanvas') {
                                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                                    ctx.drawImage(parentCanvas, 0, 0);
                                }
                            });

                            // Update on close
                            window.addEventListener('beforeunload', () => {
                                window.opener.postMessage({ type: 'popoutClosed', name: 'lattice' }, '*');
                            });
                        <\/script>
                    </body>
                    </html>
                `);
                win.document.close();

                // Store reference for updates
                this.latticePopout = win;
            }

            popoutControls() {
                // Check if already popped out
                if (this.controlsPopout && !this.controlsPopout.closed) {
                    this.controlsPopout.focus();
                    return;
                }

                const controlsDiv = document.querySelector('.controls');
                const win = window.open('about:blank', 'Controls', 'popup=yes,width=800,height=600,left=200,top=200,resizable=yes,scrollbars=yes');
                if (!win) return;

                // Hide the controls in main window
                controlsDiv.style.display = 'none';

                win.document.write(`
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>Controls</title>
                        <style>
                            body { margin: 0; padding: 20px; background: #0f0f0f; color: #e0e0e0; font-family: Arial, sans-serif; }
                            ${Array.from(document.styleSheets[0].cssRules).map(rule => rule.cssText).join('\n')}
                        </style>
                    </head>
                    <body>
                        <div class="controls" style="margin: 0;">
                            ${controlsDiv.innerHTML}
                        </div>
                        <script>
                            // Proxy all button clicks back to parent
                            document.querySelectorAll('button').forEach(button => {
                                const onclick = button.getAttribute('onclick');
                                if (onclick) {
                                    button.onclick = () => window.opener.eval(onclick);
                                }
                            });

                            // Proxy input changes
                            document.querySelectorAll('input').forEach(input => {
                                if (!window.opener) return;
                                const parentInput = window.opener.document.getElementById(input.id);
                                if (parentInput) {
                                    input.value = parentInput.value;
                                    input.checked = parentInput.checked;

                                    input.addEventListener('change', () => {
                                        parentInput.value = input.value;
                                        parentInput.checked = input.checked;
                                        const onchange = parentInput.getAttribute('onchange');
                                        if (onchange) window.opener.eval(onchange);
                                    });

                                    // Listen for updates from parent
                                    setInterval(() => {
                                        input.value = parentInput.value;
                                        input.checked = parentInput.checked;
                                    }, 100);
                                }
                            });

                            window.addEventListener('beforeunload', () => {
                                window.opener.postMessage({ type: 'popoutClosed', name: 'controls' }, '*');
                            });
                        <\/script>
                    </body>
                    </html>
                `);
                win.document.close();

                // Store reference
                this.controlsPopout = win;
            }

            popoutSelectedBlock() {
                // Check if already popped out
                if (this.selectedBlockPopout && !this.selectedBlockPopout.closed) {
                    this.selectedBlockPopout.focus();
                    return;
                }

                const selectedBlockSection = document.getElementById('selectedBlockSection');
                const selectedBlockContent = document.getElementById('selectedBlockContent');
                if (!selectedBlockContent || selectedBlockContent.innerHTML.trim() === '') {
                    alert('No selected block to display. Plot a sequence first.');
                    return;
                }

                const win = window.open('about:blank', 'SelectedBlock', 'popup=yes,width=600,height=800,left=300,top=150,resizable=yes,scrollbars=yes');
                if (!win) return;

                // Hide the selected block section in main window
                selectedBlockSection.style.display = 'none';

                win.document.write(`
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>Selected Block</title>
                        <style>
                            body { margin: 0; padding: 20px; background: #0f0f0f; color: #e0e0e0; font-family: Arial, sans-serif; }
                            ${Array.from(document.styleSheets[0].cssRules).map(rule => rule.cssText).join('\n')}
                        </style>
                    </head>
                    <body>
                        <div class="selected-block-section" style="display: block;">
                            ${selectedBlockSection.innerHTML}
                        </div>
                        <script>
                            // Listen for updates from parent
                            window.addEventListener('message', (event) => {
                                if (event.data.type === 'updateSelectedBlock') {
                                    document.querySelector('.selected-block-section').innerHTML = event.data.content;

                                    // Re-attach event handlers for spinner and links
                                    const tSpinner = document.getElementById('selectedBlockTSpinner');
                                    const succXLink = document.querySelector('.succ-x-link');

                                    if (tSpinner) {
                                        tSpinner.addEventListener('change', () => {
                                            window.opener.document.getElementById('selectedBlockTSpinner').value = tSpinner.value;
                                            window.opener.document.getElementById('selectedBlockTSpinner').dispatchEvent(new Event('change'));
                                        });
                                    }

                                    if (succXLink) {
                                        succXLink.addEventListener('click', (e) => {
                                            e.preventDefault();
                                            window.opener.document.querySelector('.succ-x-link').click();
                                        });
                                    }
                                }
                            });

                            window.addEventListener('beforeunload', () => {
                                window.opener.postMessage({ type: 'popoutClosed', name: 'selectedBlock' }, '*');
                            });
                        <\/script>
                    </body>
                    </html>
                `);
                win.document.close();

                // Store reference for updates
                this.selectedBlockPopout = win;
            }

            popoutLatticeParameters() {
                // Check if already popped out
                if (this.latticeParametersPopout && !this.latticeParametersPopout.closed) {
                    this.latticeParametersPopout.focus();
                    return;
                }

                const infoPanel = document.getElementById('infoPanel');
                const infoContent = document.getElementById('infoContent');
                if (!infoContent || infoContent.innerHTML.trim() === '') {
                    alert('No lattice parameters to display. Plot a sequence first.');
                    return;
                }

                const win = window.open('about:blank', 'LatticeParameters', 'popup=yes,width=600,height=800,left=400,top=150,resizable=yes,scrollbars=yes');
                if (!win) return;

                // Hide the info panel in main window
                infoPanel.style.display = 'none';

                win.document.write(`
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>Lattice Parameters</title>
                        <style>
                            body { margin: 0; padding: 20px; background: #0f0f0f; color: #e0e0e0; font-family: Arial, sans-serif; }
                            ${Array.from(document.styleSheets[0].cssRules).map(rule => rule.cssText).join('\n')}
                        </style>
                    </head>
                    <body>
                        <div class="info-panel" style="display: block;">
                            ${infoPanel.innerHTML}
                        </div>
                        <script>
                            // Listen for updates from parent
                            window.addEventListener('message', (event) => {
                                if (event.data.type === 'updateLatticeParameters') {
                                    document.querySelector('.info-panel').innerHTML = event.data.content;

                                    // Re-attach event handlers for congruence links
                                    document.querySelectorAll('.congruence-link').forEach(link => {
                                        link.addEventListener('click', (e) => {
                                            e.preventDefault();
                                            const href = link.getAttribute('href');
                                            if (href && href.startsWith('?')) {
                                                window.opener.location.href = href;
                                            }
                                        });
                                    });
                                }
                            });

                            window.addEventListener('beforeunload', () => {
                                window.opener.postMessage({ type: 'popoutClosed', name: 'latticeParameters' }, '*');
                            });
                        <\/script>
                    </body>
                    </html>
                `);
                win.document.close();

                // Store reference for updates
                this.latticeParametersPopout = win;
            }
        }

        // Initialize application
        const app = new Application();

        // Attach popout button event listeners
        document.getElementById('popoutLatticeBtn').addEventListener('click', () => app.popoutLattice());
        document.getElementById('popoutControlsBtn').addEventListener('click', () => app.popoutControls());
        document.getElementById('popoutSelectedBlockBtn').addEventListener('click', () => app.popoutSelectedBlock());
        document.getElementById('popoutParamsBtn').addEventListener('click', () => app.popoutLatticeParameters());

        // Plot default example on load
        window.addEventListener('load', () => {
            app.plotSequence();
            app.isInitialLoad = false;
            app.updateAnimateButton();
        });
    </script>
</body>
</html>
