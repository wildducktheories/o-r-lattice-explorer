<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>O-R Lattice: Collatz Sequence Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2em;
            margin-bottom: 10px;
            color: #4a9eff;
        }

        .subtitle {
            color: #999;
            font-size: 0.9em;
        }

        .controls {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .control-row {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        label {
            font-weight: 500;
            min-width: 80px;
        }

        input[type="number"],
        input[type="text"] {
            background: #1a1a1a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 1em;
            width: 200px;
        }

        input[type="number"]:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: #4a9eff;
        }

        button {
            background: #4a9eff;
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 4px;
            font-size: 1em;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }

        button:hover {
            background: #3a8eef;
        }

        button:active {
            background: #2a7edf;
        }

        .canvas-container {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            overflow: auto;
        }

        canvas {
            display: block;
            background: #1a1a1a;
            border: 1px solid #444;
            cursor: crosshair;
        }

        .info-panel {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .info-section {
            margin-bottom: 15px;
        }

        .info-section:last-child {
            margin-bottom: 0;
        }

        .info-label {
            font-weight: 500;
            color: #4a9eff;
            margin-bottom: 5px;
        }

        .info-value {
            font-family: 'Courier New', monospace;
            color: #e0e0e0;
            padding: 8px;
            background: #1a1a1a;
            border-radius: 4px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
        }

        .error {
            background: #4a1a1a;
            color: #ff6b6b;
            padding: 10px 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            border: 1px solid #ff6b6b;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>O-R Lattice: Collatz Sequence Visualizer</h1>
            <div class="subtitle">Explore 3x+1 sequences through the (o,r) coordinate system</div>
        </header>

        <div class="controls">
            <div class="control-row">
                <label for="x0Input">Starting value (x₀):</label>
                <input type="number" id="x0Input" value="27" min="1" step="1">
                <button onclick="app.plotSequence()">Plot Sequence</button>
                <button onclick="app.clearCanvas()">Clear</button>
            </div>
            <div class="control-row">
                <label>Examples:</label>
                <button onclick="app.loadExample(27)">27</button>
                <button onclick="app.loadExample(31)">31</button>
                <button onclick="app.loadExample(63)">63</button>
                <button onclick="app.loadExample(127)">127</button>
                <button onclick="app.loadExample(70055)">70055</button>
                <button onclick="app.loadExample(77031)">77031</button>
            </div>
            <div class="control-row">
                <label>
                    <input type="checkbox" id="showEvenTerms" onchange="app.toggleEvenTerms()">
                    Show even terms on lattice
                </label>
            </div>
            <div class="control-row">
                <label>Layers:</label>
                <label><input type="checkbox" id="layerGrid" checked onchange="app.toggleLayer('Grid')"> Grid</label>
                <label><input type="checkbox" id="layerAxes" checked onchange="app.toggleLayer('Axes')"> Axes</label>
                <label><input type="checkbox" id="layerPath" checked onchange="app.toggleLayer('Path')"> Path</label>
                <label><input type="checkbox" id="layerBlocks" onchange="app.toggleLayer('OE Blocks')"> OE Blocks</label>
                <label><input type="checkbox" id="layerMValue" onchange="app.toggleLayer('M Values')"> λₘ-layer</label>
                <label><input type="checkbox" id="layerXValue" checked onchange="app.toggleLayer('X Values')"> λₓ-layer</label>
                <label><input type="checkbox" id="layerEpsilon" onchange="app.toggleLayer('Epsilon')"> ε-layer</label>
                <button id="animateButton" onclick="app.toggleAnimation()" style="margin-left: 20px;">Animate to λₓ</button>
            </div>
        </div>

        <div id="errorPanel" class="error" style="display: none;"></div>

        <div class="canvas-container">
            <canvas id="latticeCanvas" width="1200" height="800"></canvas>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff6b6b;"></div>
                    <span>O step (3x+1)/2: moves (o,r) → (o-1, r-1)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4a9eff;"></div>
                    <span>E step x/2^β (divide out all 2s): moves (o,r) → (o, r+β-2)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(45deg, #ff00ff, #00ffff, #ffff00, #00ff00); border: 2px dashed #fff;"></div>
                    <span>Colored boxes: ((OE)+E+) blocks accelerate multiple O steps</span>
                </div>
            </div>
        </div>

        <div id="infoPanel" class="info-panel" style="display: none;">
            <div class="info-section">
                <div class="info-label">Starting Value (x₀)</div>
                <div class="info-value" id="infoContent"></div>
            </div>
        </div>

        <div class="info-panel">
            <div class="info-section">
                <div class="info-label">Sequence (OE notation):</div>
                <div id="oeSequence" class="info-value">-</div>
            </div>
            <div class="info-section">
                <div class="info-label">Sequence length:</div>
                <div id="seqLength" class="info-value">-</div>
            </div>
            <div class="info-section">
                <div class="info-label">((OE)+E+) blocks:</div>
                <div id="oeBlocks" class="info-value">-</div>
            </div>
        </div>

        <div class="canvas-container">
            <h2 style="color: #4a9eff; margin-bottom: 15px;">Heatmap: (α, β) Distribution</h2>
            <div style="color: #999; margin-bottom: 10px; font-size: 0.9em;">
                For odd x: α = v₂(x+1), β = v₂(3x+1)
            </div>
            <canvas id="heatmapCanvas" width="800" height="600"></canvas>
        </div>

    </div>

    <script>
        // Configuration
        const CONFIG = {
            maxIterations: 10000,
            gridSize: 20,
            pointRadius: 4,
            lineWidth: 2,
            colors: {
                oddStep: '#ff6b6b',    // Red for O steps (3x+1)
                evenStep: '#4a9eff',   // Blue for E steps (x/2)
                grid: '#333',
                axes: '#666',
                point: '#fff',
                blocks: [
                    '#ff00ff',  // Magenta
                    '#00ffff',  // Cyan
                    '#ffff00',  // Yellow
                    '#00ff00',  // Green
                    '#ff8800',  // Orange
                    '#8800ff',  // Purple
                    '#ff0088',  // Pink
                    '#88ff00',  // Lime
                ]
            }
        };

        // Collatz sequence computation with (o, e, r) tracking
        class CollatzSequence {
            constructor(x0) {
                this.x0 = x0;
                this.steps = [];
                this.compute();
            }

            compute() {
                // First, compute the sequence forward to get x values and types
                let x = this.x0;
                let tempSteps = [{ x: x, type: 'start' }];

                let iterations = 0;
                while (x !== 1 && iterations < CONFIG.maxIterations) {
                    if (x % 2 === 1) {
                        // Odd step: 3x+1
                        x = 3 * x + 1;
                        tempSteps.push({ x: x, type: 'O' });
                    } else {
                        // Even step: x/2
                        x = x / 2;
                        tempSteps.push({ x: x, type: 'E' });
                    }
                    iterations++;
                }

                if (iterations >= CONFIG.maxIterations) {
                    throw new Error(`Sequence did not reach 1 within ${CONFIG.maxIterations} iterations`);
                }

                // Now compute o, e, r, α, β, γ backwards from x=1 (where o=0, e=0)
                // Start from the end and work backwards
                for (let i = tempSteps.length - 1; i >= 0; i--) {
                    const currentX = tempSteps[i].x;

                    // Compute α = v_2(x+1) - power of 2 dividing (x+1) - determines upward growth
                    tempSteps[i].alpha = this.v2(currentX + 1);

                    // Compute γ = v_3(x+1) - power of 3 dividing (x+1) - neutral to growth/decay
                    tempSteps[i].gamma = this.v3(currentX + 1);

                    // Compute m = (x+1) / (2^α * 3^γ)
                    tempSteps[i].m = (currentX + 1) / (Math.pow(2, tempSteps[i].alpha) * Math.pow(3, tempSteps[i].gamma));

                    // Compute lambda_x = log_2(x) and lambda_m = log_3(m)
                    tempSteps[i].lambda_x = Math.log2(currentX);
                    tempSteps[i].lambda_m = Math.log(tempSteps[i].m) / Math.log(3);

                    if (i === tempSteps.length - 1) {
                        // At x=1: o=0, e=0, β=0
                        tempSteps[i].o = 0;
                        tempSteps[i].e = 0;
                        tempSteps[i].r = 0;
                        tempSteps[i].beta = 0;
                        tempSteps[i].n = i;
                    } else {
                        // Get successor (next step in forward direction)
                        const successor = tempSteps[i + 1];

                        // If current x is odd, o = successor.o + 1, e = successor.e
                        // If current x is even, o = successor.o, e = successor.e + 1
                        if (currentX % 2 === 1) {
                            tempSteps[i].o = successor.o + 1;
                            tempSteps[i].e = successor.e;
                            tempSteps[i].beta = successor.beta;
                        } else {
                            tempSteps[i].o = successor.o;
                            tempSteps[i].e = successor.e + 1;
                            // β = v_2(x) for even x - determines downward decay
                            tempSteps[i].beta = this.v2(currentX);
                        }

                        tempSteps[i].r = 2 * tempSteps[i].o - tempSteps[i].e;
                        tempSteps[i].n = i;
                    }

                    // Compute d = 2^(2o-r) - 3^o (after o and r are set)
                    tempSteps[i].d = Math.pow(2, 2 * tempSteps[i].o - tempSteps[i].r) - Math.pow(3, tempSteps[i].o);

                    // Compute k = 2^e - 3^o * x (after o and e are set)
                    tempSteps[i].k = Math.pow(2, tempSteps[i].e) - Math.pow(3, tempSteps[i].o) * currentX;

                    // Compute lambda_k = log_2(k)
                    tempSteps[i].lambda_k = Math.log2(Math.abs(tempSteps[i].k));
                }

                this.steps = tempSteps;
            }

            // Compute v_2(n) - the 2-adic valuation (power of 2 dividing n)
            v2(n) {
                if (n === 0) return Infinity;
                let count = 0;
                while (n % 2 === 0) {
                    count++;
                    n = n / 2;
                }
                return count;
            }

            // Compute v_3(n) - the 3-adic valuation (power of 3 dividing n)
            v3(n) {
                if (n === 0) return Infinity;
                let count = 0;
                while (n % 3 === 0) {
                    count++;
                    n = n / 3;
                }
                return count;
            }

            getOEString() {
                return this.steps
                    .filter(s => s.type !== 'start')
                    .map(s => s.type)
                    .join('');
            }

            getBounds() {
                const oValues = this.steps.map(s => s.o);
                const rValues = this.steps.map(s => s.r);
                return {
                    minO: Math.min(...oValues),
                    maxO: Math.max(...oValues),
                    minR: Math.min(...rValues),
                    maxR: Math.max(...rValues)
                };
            }

            findOEBlocks() {
                // Find blocks matching ((OE)+E+) pattern
                const oeString = this.getOEString();
                const blocks = [];
                let i = 0;

                while (i < oeString.length) {
                    // Check if we're starting an (OE)+ sequence
                    if (i < oeString.length - 1 && oeString[i] === 'O' && oeString[i + 1] === 'E') {
                        const blockStart = i;

                        // Count (OE)+ pairs
                        while (i < oeString.length - 1 && oeString[i] === 'O' && oeString[i + 1] === 'E') {
                            i += 2;
                        }

                        // Mark where (OE)+ ends - this is the last E in the OE pairs
                        const oeEndIndex = i - 1;

                        // Check for E+ following the (OE)+ sequence
                        const eStart = i;
                        while (i < oeString.length && oeString[i] === 'E') {
                            i++;
                        }

                        // Only count as a block if we have at least one E after (OE)+
                        if (i > eStart) {
                            blocks.push({
                                start: blockStart,
                                end: i - 1,
                                oeEndIndex: oeEndIndex,  // Index of last E in (OE)+
                                pattern: oeString.substring(blockStart, i)
                            });
                        }
                    } else {
                        i++;
                    }
                }

                return blocks;
            }

            getAlphaBetaDistribution() {
                // Count occurrences of each (β, α) pair for ODD x values only
                const counts = new Map();

                for (const step of this.steps) {
                    // Only include odd x values (matching Python: if s.x%2==1)
                    if (step.x % 2 === 1) {
                        const key = `${step.beta},${step.alpha}`;
                        counts.set(key, (counts.get(key) || 0) + 1);
                    }
                }

                // Convert to array of {beta, alpha, count}
                const distribution = [];
                for (const [key, count] of counts.entries()) {
                    const [beta, alpha] = key.split(',').map(Number);
                    distribution.push({ beta, alpha, count });
                }

                return distribution;
            }

            getBlockForStep(stepIndex) {
                // Find which ((OE)+E+) block contains this step
                // A block with OE indices [start, end] includes:
                // - steps[start]: the starting odd term (before first transition)
                // - steps[start+1] through steps[end+1]: the transitions
                // So the block spans steps[start] through steps[end+1]

                const blocks = this.findOEBlocks();

                for (const block of blocks) {
                    // Check if stepIndex is within this block's range
                    if (stepIndex >= block.start && stepIndex <= block.end + 1) {
                        return block.pattern;
                    }
                }

                return null;
            }

            getLastEvenInOEPlusIndices() {
                // Returns step indices of the last even term in each (OE)+ sequence
                // These should be shown even when "Show even terms" is unchecked
                const blocks = this.findOEBlocks();
                const indices = [];

                for (const block of blocks) {
                    // oeEndIndex is the OE string index of the last E in (OE)+
                    // Convert to step index: oeEndIndex + 1 (since steps[0] is start)
                    const stepIndex = block.oeEndIndex + 1;
                    indices.push(stepIndex);
                }

                return indices;
            }
        }

        // Base Layer class for rendering system
        class Layer {
            constructor(name, enabled = true) {
                this.name = name;
                this.enabled = enabled;
                this.usesRightAxis = false;
                this.rightAxisLabel = '';
            }

            render(ctx, sequences, latticeTransform, rightAxisTransform = null) {
                // Override in subclasses
            }

            getRightAxisBounds(sequences) {
                // Override if usesRightAxis = true
                return null;
            }
        }

        // Grid layer - background grid lines
        class GridLayer extends Layer {
            constructor(enabled = true) {
                super('Grid', enabled);
            }

            render(ctx, sequences, latticeTransform) {
                if (sequences.length === 0) return;

                // Calculate bounds from visible steps
                let minO = Infinity, maxO = -Infinity;
                let minR = Infinity, maxR = -Infinity;

                for (const seq of sequences) {
                    const visibleSteps = latticeTransform.getVisibleSteps(seq);
                    for (const step of visibleSteps) {
                        minO = Math.min(minO, step.o);
                        maxO = Math.max(maxO, step.o);
                        minR = Math.min(minR, step.r);
                        maxR = Math.max(maxR, step.r);
                    }
                }

                minO = Math.floor(minO) - 2;
                maxO = Math.ceil(maxO) + 2;
                minR = Math.floor(minR) - 2;
                maxR = Math.ceil(maxR) + 2;

                ctx.strokeStyle = CONFIG.colors.grid;
                ctx.lineWidth = 0.5;

                // Vertical grid lines (constant o)
                for (let o = minO; o <= maxO; o++) {
                    const x = latticeTransform.toScreenX(o);
                    ctx.beginPath();
                    ctx.moveTo(x, latticeTransform.toScreenY(minR));
                    ctx.lineTo(x, latticeTransform.toScreenY(maxR));
                    ctx.stroke();
                }

                // Horizontal grid lines (constant r)
                for (let r = minR; r <= maxR; r++) {
                    const y = latticeTransform.toScreenY(r);
                    ctx.beginPath();
                    ctx.moveTo(latticeTransform.toScreenX(minO), y);
                    ctx.lineTo(latticeTransform.toScreenX(maxO), y);
                    ctx.stroke();
                }
            }
        }

        // Axes layer - O and R coordinate axes
        class AxesLayer extends Layer {
            constructor(enabled = true) {
                super('Axes', enabled);
            }

            render(ctx, sequences, latticeTransform) {
                if (sequences.length === 0) return;

                // Calculate bounds
                let minO = Infinity, maxO = -Infinity;
                let minR = Infinity, maxR = -Infinity;

                for (const seq of sequences) {
                    const visibleSteps = latticeTransform.getVisibleSteps(seq);
                    for (const step of visibleSteps) {
                        minO = Math.min(minO, step.o);
                        maxO = Math.max(maxO, step.o);
                        minR = Math.min(minR, step.r);
                        maxR = Math.max(maxR, step.r);
                    }
                }

                minO = Math.floor(minO) - 2;
                maxO = Math.ceil(maxO) + 2;
                minR = Math.floor(minR) - 2;
                maxR = Math.ceil(maxR) + 2;

                ctx.strokeStyle = CONFIG.colors.axes;
                ctx.lineWidth = 2;

                // O-axis (r = 0)
                if (minR <= 0 && maxR >= 0) {
                    const y = latticeTransform.toScreenY(0);
                    ctx.beginPath();
                    ctx.moveTo(latticeTransform.toScreenX(minO), y);
                    ctx.lineTo(latticeTransform.toScreenX(maxO), y);
                    ctx.stroke();
                }

                // R-axis (o = 0)
                if (minO <= 0 && maxO >= 0) {
                    const x = latticeTransform.toScreenX(0);
                    ctx.beginPath();
                    ctx.moveTo(x, latticeTransform.toScreenY(minR));
                    ctx.lineTo(x, latticeTransform.toScreenY(maxR));
                    ctx.stroke();
                }

                // Labels
                ctx.fillStyle = CONFIG.colors.axes;
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('o →', latticeTransform.toScreenX(maxO) - 20, latticeTransform.toScreenY(0) - 10);
                ctx.save();
                ctx.translate(latticeTransform.toScreenX(0) + 20, latticeTransform.toScreenY(maxR) + 20);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('r →', 0, 0);
                ctx.restore();
            }
        }

        // OE Blocks layer - ((OE)+E+) block visualization
        class OEBlocksLayer extends Layer {
            constructor(enabled = false) {
                super('OE Blocks', enabled);
            }

            render(ctx, sequences, latticeTransform) {
                for (const sequence of sequences) {
                    const blocks = sequence.findOEBlocks();

                    for (let blockIdx = 0; blockIdx < blocks.length; blockIdx++) {
                        const block = blocks[blockIdx];
                        const color = CONFIG.colors.blocks[blockIdx % CONFIG.colors.blocks.length];

                        const startStepIdx = block.start;
                        const endStepIdx = block.end + 1;
                        const blockSteps = sequence.steps.slice(startStepIdx, endStepIdx + 1);

                        if (blockSteps.length < 2) continue;

                        // Find bounding box
                        const oValues = blockSteps.map(s => s.o);
                        const rValues = blockSteps.map(s => s.r);
                        const minO = Math.min(...oValues);
                        const maxO = Math.max(...oValues);
                        const minR = Math.min(...rValues);
                        const maxR = Math.max(...rValues);

                        const padding = 10;
                        const x1 = latticeTransform.toScreenX(minO) - padding;
                        const y1 = latticeTransform.toScreenY(maxR) - padding;
                        const width = latticeTransform.toScreenX(maxO) - latticeTransform.toScreenX(minO) + padding * 2;
                        const height = latticeTransform.toScreenY(minR) - latticeTransform.toScreenY(maxR) + padding * 2;

                        // Draw semi-transparent box
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 3;
                        ctx.setLineDash([5, 5]);
                        ctx.strokeRect(x1, y1, width, height);
                        ctx.setLineDash([]);

                        ctx.fillStyle = color + '20';
                        ctx.fillRect(x1, y1, width, height);

                        // Label
                        ctx.fillStyle = color;
                        ctx.font = 'bold 12px sans-serif';
                        ctx.textAlign = 'left';
                        ctx.fillText(block.pattern, x1 + 5, y1 + 15);
                    }
                }
            }
        }

        // Path layer - sequence paths and points
        class PathLayer extends Layer {
            constructor(enabled = true) {
                super('Path', enabled);
            }

            render(ctx, sequences, latticeTransform) {
                const t = latticeTransform.animationT || 0;

                for (const sequence of sequences) {
                    // Get visible steps
                    const filteredSteps = latticeTransform.getVisibleSteps(sequence);

                    // Always draw original lattice at (o, r) in gold
                    // Draw edges
                    for (let i = 0; i < filteredSteps.length - 1; i++) {
                        const curr = filteredSteps[i];
                        const next = filteredSteps[i + 1];

                        const x1 = latticeTransform.toScreenX(curr.o);
                        const y1 = latticeTransform.toScreenY(curr.r);
                        const x2 = latticeTransform.toScreenX(next.o);
                        const y2 = latticeTransform.toScreenY(next.r);

                        ctx.strokeStyle = next.type === 'O' ? CONFIG.colors.oddStep : CONFIG.colors.evenStep;
                        ctx.lineWidth = CONFIG.lineWidth;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }

                    // Draw original points
                    for (let i = 0; i < filteredSteps.length; i++) {
                        const step = filteredSteps[i];
                        const x = latticeTransform.toScreenX(step.o);
                        const y = latticeTransform.toScreenY(step.r);

                        ctx.fillStyle = 'rgba(255, 215, 0, 0.6)';  // Semi-transparent gold
                        ctx.beginPath();
                        ctx.arc(x, y, CONFIG.pointRadius, 0, 2 * Math.PI);
                        ctx.fill();

                        // Label start and end
                        if (i === 0 || i === filteredSteps.length - 1) {
                            ctx.fillStyle = '#fff';
                            ctx.font = 'bold 12px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.fillText(
                                i === 0 ? `Start (${step.x})` : `End (${step.x})`,
                                x,
                                y - 15
                            );
                        }
                    }

                    // If animating, draw animated copy morphing to (o, -log₂(x)) with color change
                    if (t > 0) {
                        // Interpolate color from gold to green
                        const r = Math.round(255 * (1 - t) + 50 * t);
                        const g = Math.round(215 * (1 - t) + 205 * t);
                        const b = Math.round(0 * (1 - t) + 50 * t);
                        const alpha = 0.6 * (1 - t) + 0.5 * t;

                        // Draw animated edges
                        for (let i = 0; i < filteredSteps.length - 1; i++) {
                            const curr = filteredSteps[i];
                            const next = filteredSteps[i + 1];

                            const x1 = latticeTransform.toScreenX(curr.o);
                            const y1 = latticeTransform.toScreenY(latticeTransform.getAnimatedY(curr));
                            const x2 = latticeTransform.toScreenX(next.o);
                            const y2 = latticeTransform.toScreenY(latticeTransform.getAnimatedY(next));

                            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                            ctx.lineWidth = CONFIG.lineWidth;

                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }

                        // Draw animated points
                        for (let i = 0; i < filteredSteps.length; i++) {
                            const step = filteredSteps[i];
                            const x = latticeTransform.toScreenX(step.o);
                            const y = latticeTransform.toScreenY(latticeTransform.getAnimatedY(step));

                            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                            ctx.beginPath();
                            ctx.arc(x, y, CONFIG.pointRadius, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                    }
                }
            }
        }

        // M Value layer - λ_m vs o with γ as circle size (right-axis)
        class MValueLayer extends Layer {
            constructor(enabled = false) {
                super('M Values', enabled);
                this.usesRightAxis = true;
                this.rightAxisLabel = 'λₘ = log₃(m)';
            }

            getRightAxisBounds(sequences) {
                let minLambdaM = Infinity;
                let maxLambdaM = -Infinity;
                for (const seq of sequences) {
                    for (const step of seq.steps) {
                        if (step.x % 2 === 1) {
                            minLambdaM = Math.min(minLambdaM, step.lambda_m);
                            maxLambdaM = Math.max(maxLambdaM, step.lambda_m);
                        }
                    }
                }
                return { min: minLambdaM, max: maxLambdaM };
            }

            render(ctx, sequences, latticeTransform, rightAxisTransform) {
                if (!rightAxisTransform) return;

                ctx.fillStyle = 'rgba(255, 68, 68, 0.5)';  // Semi-transparent red
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';  // Semi-transparent black stroke
                ctx.lineWidth = 1;

                for (const seq of sequences) {
                    for (const step of seq.steps) {
                        if (step.x % 2 === 1) {
                            const x = latticeTransform.toScreenX(step.o);
                            const y = rightAxisTransform.toScreenY(step.lambda_m);
                            const radius = step.gamma + 3;

                            ctx.beginPath();
                            ctx.arc(x, y, radius, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.stroke();
                        }
                    }
                }
            }
        }

        // X Value layer - plots at (o, -log₂(x)) on left axis with β as circle size
        // and draws L-shaped lines: vertical from (o,r) down, horizontal from (o,r)-estimator
        class XValueLayer extends Layer {
            constructor(enabled = true) {
                super('X Values', enabled);
                this.usesRightAxis = false;
            }

            render(ctx, sequences, latticeTransform, rightAxisTransform) {
                const theta = 2 - Math.log2(3);

                // Determine which step should have the horizontal line
                const highlightStep = latticeTransform.hoveredPoint
                    ? latticeTransform.hoveredPoint.step
                    : latticeTransform.defaultStep;

                // Draw horizontal line for highlighted step (works for both odd and even x)
                if (highlightStep) {
                    const o = highlightStep.o;
                    const r = highlightStep.r;
                    const negLogX = -highlightStep.lambda_x;

                    // Find intersection of horizontal line at r = -log₂(x)
                    // with x-estimator (theta slope line through (o, r))
                    // x-estimator: r_line = θ·(o_point - o) + r
                    // Horizontal: r_line = -log₂(x)
                    // Intersection: o_int = o + (-log₂(x) - r)/θ
                    const o_int = o + (negLogX - r) / theta;

                    // Draw vertical line from lattice point (o,r) to (o, -log₂(x))
                    ctx.strokeStyle = 'rgba(50, 205, 50, 0.6)';  // Semi-transparent green (lime green)
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([4, 2]);
                    ctx.beginPath();
                    ctx.moveTo(latticeTransform.toScreenX(o), latticeTransform.toScreenY(r));
                    ctx.lineTo(latticeTransform.toScreenX(o), latticeTransform.toScreenY(negLogX));
                    ctx.stroke();

                    // Draw horizontal line from intersection to x point
                    ctx.beginPath();
                    ctx.moveTo(latticeTransform.toScreenX(o_int), latticeTransform.toScreenY(negLogX));
                    ctx.lineTo(latticeTransform.toScreenX(o), latticeTransform.toScreenY(negLogX));
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw circle at highlighted point's lambda_x position
                    const x = latticeTransform.toScreenX(o);
                    const y = latticeTransform.toScreenY(negLogX);
                    const radius = highlightStep.beta + 3;

                    ctx.fillStyle = 'rgba(50, 205, 50, 0.5)';  // Semi-transparent green (lime green)
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';  // Semi-transparent black stroke
                    ctx.lineWidth = 1;

                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }

                // Draw circles only for odd x values
                for (const seq of sequences) {
                    for (const step of seq.steps) {
                        if (step.x % 2 === 1) {
                            const o = step.o;
                            const negLogX = -step.lambda_x;

                            // Draw circle at x point
                            const x = latticeTransform.toScreenX(o);
                            const y = latticeTransform.toScreenY(negLogX);
                            const radius = step.beta + 3;

                            ctx.fillStyle = 'rgba(50, 205, 50, 0.5)';  // Semi-transparent green (lime green)
                            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';  // Semi-transparent black stroke
                            ctx.lineWidth = 1;

                            ctx.beginPath();
                            ctx.arc(x, y, radius, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.stroke();
                        }
                    }
                }
            }
        }

        // Epsilon layer - plots ε = (cₒ,ᵣ - cₓ)/√(1+θ²) on right axis
        class EpsilonLayer extends Layer {
            constructor(enabled = false) {
                super('Epsilon', enabled);
                this.usesRightAxis = true;
                this.rightAxisLabel = 'ε = (cₒ,ᵣ - cₓ)/√(1+θ²)';
            }

            getRightAxisBounds(sequences) {
                const theta = 2 - Math.log2(3);
                const normFactor = Math.sqrt(1 + theta * theta);

                let minEpsilon = Infinity;
                let maxEpsilon = -Infinity;

                for (const seq of sequences) {
                    for (const step of seq.steps) {
                        if (step.x % 2 === 1) {
                            const c_or = theta * step.o - step.r;
                            const c_x = Math.log2(step.x);
                            const epsilon = (c_or - c_x) / normFactor;

                            minEpsilon = Math.min(minEpsilon, epsilon);
                            maxEpsilon = Math.max(maxEpsilon, epsilon);
                        }
                    }
                }

                return { min: minEpsilon, max: maxEpsilon };
            }

            render(ctx, sequences, latticeTransform, rightAxisTransform) {
                if (!rightAxisTransform) return;

                const theta = 2 - Math.log2(3);
                const normFactor = Math.sqrt(1 + theta * theta);

                ctx.fillStyle = 'rgba(255, 0, 255, 0.5)';  // Semi-transparent magenta
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 1;

                for (const seq of sequences) {
                    for (const step of seq.steps) {
                        if (step.x % 2 === 1) {
                            const c_or = theta * step.o - step.r;
                            const c_x = Math.log2(step.x);
                            const epsilon = (c_or - c_x) / normFactor;

                            const x = latticeTransform.toScreenX(step.o);
                            const y = rightAxisTransform.toScreenY(epsilon);
                            const radius = 4; // Fixed size for epsilon points

                            ctx.beginPath();
                            ctx.arc(x, y, radius, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.stroke();
                        }
                    }
                }
            }
        }

        // Canvas renderer for the O-R lattice
        class LatticeRenderer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.sequences = [];
                this.transform = {
                    offsetX: 0,
                    offsetY: 0,
                    scale: 1
                };
                this.hoveredPoint = null;
                this.showEvenTerms = false; // Default to false - only show odd terms

                // Layer management
                this.layers = [];
                this.rightAxisLayers = [];
                this.rightAxisScale = null;

                // Animation state
                this.animationT = 0; // 0 = normal (o,r), 1 = transformed (o,-log₂(x))
                this.isAnimating = false;
                this.animationDirection = 1; // 1 = forward, -1 = backward

                this.initializeLayers();
                this.setupEventListeners();
            }

            initializeLayers() {
                // Add layers in rendering order
                this.addLayer(new GridLayer());
                this.addLayer(new AxesLayer());
                this.addLayer(new OEBlocksLayer());
                this.addLayer(new PathLayer());
                this.addLayer(new XValueLayer());

                // Right-axis layers
                this.addRightAxisLayer(new MValueLayer());
                this.addRightAxisLayer(new EpsilonLayer());
            }

            addLayer(layer) {
                this.layers.push(layer);
            }

            addRightAxisLayer(layer) {
                this.rightAxisLayers.push(layer);
            }

            findLayer(name) {
                // Search in both arrays
                let layer = this.layers.find(l => l.name === name);
                if (!layer) {
                    layer = this.rightAxisLayers.find(l => l.name === name);
                }
                return layer;
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    this.hoveredPoint = this.findPointAtPosition(mouseX, mouseY);
                    this.render();
                });

                this.canvas.addEventListener('mouseleave', () => {
                    this.hoveredPoint = null;
                    this.render();
                });

                this.canvas.addEventListener('dblclick', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    const point = this.findPointAtPosition(mouseX, mouseY);
                    if (point && this.onPointDoubleClick) {
                        this.onPointDoubleClick(point.step.x);
                    }
                });
            }

            startAnimation() {
                if (this.isAnimating) return;

                this.isAnimating = true;
                // Toggle direction based on current position
                if (this.animationT >= 1) {
                    this.animationDirection = -1; // Go back to normal
                } else if (this.animationT <= 0) {
                    this.animationDirection = 1; // Go to lambda_x
                }

                this.animateStep();
            }

            animateStep() {
                if (!this.isAnimating) return;

                const duration = 1500; // 1.5 seconds
                const deltaT = (this.animationDirection * 16) / duration; // Approx 16ms per frame

                this.animationT += deltaT;

                // Clamp and stop at bounds
                if (this.animationT >= 1) {
                    this.animationT = 1;
                    this.isAnimating = false;
                } else if (this.animationT <= 0) {
                    this.animationT = 0;
                    this.isAnimating = false;
                }

                // Apply easing (smooth start and stop)
                const t = this.animationT;
                const easedT = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

                this.currentEasedT = easedT;
                this.render();

                if (this.isAnimating) {
                    requestAnimationFrame(() => this.animateStep());
                } else {
                    // Animation completed, update button text
                    if (this.onAnimationComplete) {
                        this.onAnimationComplete();
                    }
                }
            }

            getAnimatedY(step) {
                // Interpolate between r and -log₂(x)
                const t = this.currentEasedT || 0;
                return (1 - t) * step.r + t * (-step.lambda_x);
            }

            findPointAtPosition(mouseX, mouseY) {
                const hoverRadius = 10; // pixels

                for (const seq of this.sequences) {
                    const visibleSteps = this.getVisibleSteps(seq);

                    for (const step of visibleSteps) {
                        const x = this.toScreenX(step.o);
                        const y = this.toScreenY(step.r);
                        const dx = mouseX - x;
                        const dy = mouseY - y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance <= hoverRadius) {
                            // Return both step and sequence
                            return { step, sequence: seq };
                        }
                    }
                }
                return null;
            }

            getVisibleSteps(sequence) {
                // Returns steps that should be visible based on showEvenTerms setting
                if (this.showEvenTerms) {
                    return sequence.steps;
                } else {
                    // Show odd x, start, and last even in each (OE)+ sequence
                    const lastEvenIndices = new Set(sequence.getLastEvenInOEPlusIndices());
                    return sequence.steps.filter((s, idx) =>
                        s.x % 2 === 1 || s.type === 'start' || lastEvenIndices.has(idx)
                    );
                }
            }

            clear() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.sequences = [];
            }

            addSequence(sequence) {
                this.sequences.push(sequence);
                this.fitToView();
                this.render();
            }

            fitToView() {
                if (this.sequences.length === 0) return;

                // Get combined bounds from visible steps
                let minO = Infinity, maxO = -Infinity;
                let minR = Infinity, maxR = -Infinity;

                for (const seq of this.sequences) {
                    const visibleSteps = this.getVisibleSteps(seq);

                    for (const step of visibleSteps) {
                        minO = Math.min(minO, step.o);
                        maxO = Math.max(maxO, step.o);
                        minR = Math.min(minR, step.r);
                        maxR = Math.max(maxR, step.r);

                        // Also consider lambda_x values for viewport bounds
                        const negLogX = -step.lambda_x;
                        minR = Math.min(minR, negLogX);
                        maxR = Math.max(maxR, negLogX);
                    }
                }

                // Add padding
                const padding = 2;
                minO -= padding;
                maxO += padding;
                minR -= padding;
                maxR += padding;

                // Calculate scale to fit
                const rangeO = maxO - minO;
                const rangeR = maxR - minR;
                const scaleO = (this.canvas.width - 100) / rangeO;
                const scaleR = (this.canvas.height - 100) / rangeR;
                this.transform.scale = Math.min(scaleO, scaleR, CONFIG.gridSize);

                // Center the view
                this.transform.offsetX = 50 - minO * this.transform.scale;
                this.transform.offsetY = this.canvas.height - 50 + minR * this.transform.scale;
            }

            toScreenX(o) {
                return this.transform.offsetX + o * this.transform.scale;
            }

            toScreenY(r) {
                return this.transform.offsetY - r * this.transform.scale;
            }

            calculateRightAxisScale() {
                // Calculate bounds for all enabled right-axis layers
                let minValue = Infinity;
                let maxValue = -Infinity;
                let hasEnabledLayers = false;

                for (const layer of this.rightAxisLayers) {
                    if (layer.enabled) {
                        const bounds = layer.getRightAxisBounds(this.sequences);
                        if (bounds) {
                            minValue = Math.min(minValue, bounds.min);
                            maxValue = Math.max(maxValue, bounds.max);
                            hasEnabledLayers = true;
                        }
                    }
                }

                if (!hasEnabledLayers) {
                    this.rightAxisScale = null;
                    return;
                }

                // Add some padding
                const range = maxValue - minValue;
                const padding = range * 0.1;
                minValue -= padding;
                maxValue += padding;

                this.rightAxisScale = {
                    min: minValue,
                    max: maxValue,
                    range: maxValue - minValue
                };
            }

            drawRightAxis() {
                if (!this.rightAxisScale) return;

                // Calculate right axis position (right edge of canvas with margin)
                const margin = 80;
                const axisX = this.canvas.width - margin;

                // Get canvas bounds in screen coordinates
                const topY = 50;
                const bottomY = this.canvas.height - 50;

                // Helper to convert value to screen Y
                const valueToScreenY = (value) => {
                    const normalized = (value - this.rightAxisScale.min) / this.rightAxisScale.range;
                    return bottomY - normalized * (bottomY - topY);
                };

                // Draw axis line
                this.ctx.strokeStyle = CONFIG.colors.axes;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(axisX, topY);
                this.ctx.lineTo(axisX, bottomY);
                this.ctx.stroke();

                // Draw tick marks and labels
                this.ctx.fillStyle = '#e0e0e0';  // Brighter tick text
                this.ctx.font = '12px sans-serif';
                this.ctx.textAlign = 'left';
                this.ctx.textBaseline = 'middle';

                // Calculate nice tick intervals
                const numTicks = 5;
                const tickStep = this.rightAxisScale.range / numTicks;

                for (let i = 0; i <= numTicks; i++) {
                    const value = this.rightAxisScale.min + i * tickStep;
                    const y = valueToScreenY(value);

                    // Tick mark
                    this.ctx.strokeStyle = CONFIG.colors.axes;
                    this.ctx.beginPath();
                    this.ctx.moveTo(axisX - 5, y);
                    this.ctx.lineTo(axisX + 5, y);
                    this.ctx.stroke();

                    // Label
                    this.ctx.fillText(value.toFixed(1), axisX + 10, y);
                }

                // Draw λₘ = 0 line if 0 is within range
                if (this.rightAxisScale.min <= 0 && this.rightAxisScale.max >= 0) {
                    const zeroY = valueToScreenY(0);
                    this.ctx.strokeStyle = '#888';
                    this.ctx.lineWidth = 1;
                    this.ctx.setLineDash([5, 3]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(50, zeroY);
                    this.ctx.lineTo(this.canvas.width - margin, zeroY);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }

                // Draw axis labels for enabled layers
                const enabledLabels = this.rightAxisLayers
                    .filter(l => l.enabled && l.rightAxisLabel)
                    .map(l => l.rightAxisLabel);

                if (enabledLabels.length > 0) {
                    this.ctx.save();
                    this.ctx.translate(this.canvas.width - 20, (topY + bottomY) / 2);
                    this.ctx.rotate(-Math.PI / 2);
                    this.ctx.textAlign = 'center';
                    this.ctx.fillStyle = '#e0e0e0';  // Brighter axis label
                    this.ctx.fillText(enabledLabels.join(', '), 0, 0);
                    this.ctx.restore();
                }
            }

            render() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Calculate right axis bounds from enabled layers
                this.calculateRightAxisScale();

                // Create lattice transform object for layers
                const latticeTransform = {
                    toScreenX: this.toScreenX.bind(this),
                    toScreenY: this.toScreenY.bind(this),
                    getVisibleSteps: this.getVisibleSteps.bind(this),
                    hoveredPoint: this.hoveredPoint,
                    defaultStep: this.sequences.length > 0 ? this.sequences[0].steps[0] : null,
                    getAnimatedY: this.getAnimatedY.bind(this),
                    animationT: this.currentEasedT || 0
                };

                // Create right axis transform if needed
                let rightAxisTransform = null;
                if (this.rightAxisScale) {
                    const margin = 80;
                    const axisX = this.canvas.width - margin;
                    const topY = 50;
                    const bottomY = this.canvas.height - 50;

                    rightAxisTransform = {
                        toScreenX: this.toScreenX.bind(this),
                        toScreenY: (value) => {
                            const normalized = (value - this.rightAxisScale.min) / this.rightAxisScale.range;
                            return bottomY - normalized * (bottomY - topY);
                        }
                    };
                }

                // Render regular layers
                for (const layer of this.layers) {
                    if (layer.enabled) {
                        layer.render(this.ctx, this.sequences, latticeTransform);
                    }
                }

                // Draw right axis
                this.drawRightAxis();

                // Render right-axis layers
                for (const layer of this.rightAxisLayers) {
                    if (layer.enabled) {
                        layer.render(this.ctx, this.sequences, latticeTransform, rightAxisTransform);
                    }
                }

                // Draw theta reference lines
                this.drawThetaLines();

                // Draw lambda_x reference line
                this.drawLambdaXLine(rightAxisTransform);

                // Draw tooltip last (on top)
                if (this.hoveredPoint) {
                    this.drawTooltip(this.hoveredPoint);
                }
            }

            drawThetaLines() {
                if (this.sequences.length === 0) return;

                // Calculate theta = 2 - log_2(3)
                const theta = 2 - Math.log2(3);

                // Determine which point to use for reference
                let refStep;
                if (this.hoveredPoint) {
                    refStep = this.hoveredPoint.step;
                } else {
                    // Use the first step (x0) of the first sequence
                    refStep = this.sequences[0].steps[0];
                }

                // Get bounds for drawing lines across the canvas
                let minO = Infinity, maxO = -Infinity;
                for (const seq of this.sequences) {
                    const visibleSteps = this.getVisibleSteps(seq);
                    for (const step of visibleSteps) {
                        minO = Math.min(minO, step.o);
                        maxO = Math.max(maxO, step.o);
                    }
                }
                minO = Math.floor(minO) - 2;
                maxO = Math.ceil(maxO) + 2;

                // Line 1: x-estimator - passes through (o_ref, r_ref)
                // Given (o,r), estimates x from r-axis intercept
                const c1 = refStep.r - theta * refStep.o;
                const r1_start = theta * minO + c1;
                const r1_end = theta * maxO + c1;

                this.ctx.strokeStyle = 'rgba(255, 140, 0, 0.6)';  // Semi-transparent orange
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([6, 3]);
                this.ctx.beginPath();
                this.ctx.moveTo(this.toScreenX(minO), this.toScreenY(r1_start));
                this.ctx.lineTo(this.toScreenX(maxO), this.toScreenY(r1_end));
                this.ctx.stroke();

                // Line 2: (o,r)-estimator - passes through (0, -log_2(x_ref))
                // Given x, estimates where (o,r) should fall
                const c2 = -Math.log2(refStep.x);
                const r2_start = theta * minO + c2;
                const r2_end = theta * maxO + c2;

                this.ctx.strokeStyle = 'rgba(255, 69, 0, 0.6)';  // Semi-transparent red-orange
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([3, 3]);
                this.ctx.beginPath();
                this.ctx.moveTo(this.toScreenX(minO), this.toScreenY(r2_start));
                this.ctx.lineTo(this.toScreenX(maxO), this.toScreenY(r2_end));
                this.ctx.stroke();

                // Line 3: Passes through origin (0, 0)
                // r = theta * o (intercept = 0)
                const r3_start = theta * minO;
                const r3_end = theta * maxO;

                this.ctx.strokeStyle = 'rgba(128, 128, 128, 0.5)';  // Semi-transparent gray
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([2, 2]);
                this.ctx.beginPath();
                this.ctx.moveTo(this.toScreenX(minO), this.toScreenY(r3_start));
                this.ctx.lineTo(this.toScreenX(maxO), this.toScreenY(r3_end));
                this.ctx.stroke();

                // Reset line dash
                this.ctx.setLineDash([]);
            }

            drawLambdaXLine(rightAxisTransform) {
                if (!rightAxisTransform || this.sequences.length === 0) return;

                // Find the XValueLayer to check orientation setting
                const xValueLayer = this.rightAxisLayers.find(l => l instanceof XValueLayer);
                if (!xValueLayer) return;

                const flipOrientation = xValueLayer.flipOrientation;
                let value;

                // Use hovered point if available, otherwise use initial x0
                if (this.hoveredPoint) {
                    value = flipOrientation ? -this.hoveredPoint.step.lambda_x : this.hoveredPoint.step.lambda_x;
                } else {
                    // Use the first step (x0) of the first sequence
                    value = flipOrientation ? -this.sequences[0].steps[0].lambda_x : this.sequences[0].steps[0].lambda_x;
                }

                const y = rightAxisTransform.toScreenY(value);
                const margin = 80;

                // Draw horizontal line across canvas at lambda_x (or -lambda_x)
                this.ctx.strokeStyle = 'rgba(68, 200, 255, 0.7)';  // Cyan to match X layer
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([8, 4]);
                this.ctx.beginPath();
                this.ctx.moveTo(50, y);
                this.ctx.lineTo(this.canvas.width - margin, y);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }

            drawTooltip(hoveredPoint) {
                const step = hoveredPoint.step;
                const sequence = hoveredPoint.sequence;

                const x = this.toScreenX(step.o);
                const y = this.toScreenY(step.r);

                // Highlight the hovered point
                this.ctx.fillStyle = '#ffff00';
                this.ctx.beginPath();
                this.ctx.arc(x, y, CONFIG.pointRadius + 2, 0, 2 * Math.PI);
                this.ctx.fill();

                // Find which block this step belongs to
                const stepIndex = step.n;
                const blockPattern = sequence.getBlockForStep(stepIndex);

                // Build tooltip text lines in order: o, r, e, x, j, i, m, k
                const lines = [];

                // Optional block pattern at top
                if (blockPattern) {
                    lines.push(blockPattern);
                }

                // Lattice position
                lines.push(`o = ${step.o}`);
                lines.push(`r = ${step.r}`);
                lines.push(`e = ${step.e}`);

                // Element
                lines.push(`x = 2^α·3^γ·m - 1 = ${step.x}`);
                lines.push(`λₓ = log₂(x) = ${step.lambda_x.toFixed(3)}`);

                // Derived parameters (in derivation order)
                lines.push(`α = v₂(x+1) = ${step.alpha}`);
                lines.push(`γ = v₃(x+1) = ${step.gamma}`);
                lines.push(`m = (x+1)/(2^α·3^γ) = ${step.m}`);
                lines.push(`λₘ = log₃(m) = ${step.lambda_m.toFixed(3)}`);
                lines.push(`β = v₂(${step.x % 2 === 0 ? 'x' : '3x+1'}) = ${step.beta}`);
                lines.push(`d = 2^(2o-r) - 3^o = ${step.d}`);
                lines.push(`k = 2^e - 3^o·x = ${step.k}`);
                lines.push(`λₖ = log₂(k) = ${step.lambda_k.toFixed(3)}`);

                // Theta-line intercepts and distances
                const theta = 2 - Math.log2(3);
                const c_or = theta * step.o - step.r;
                const c_x = Math.log2(step.x);
                const normFactor = Math.sqrt(1 + theta * theta);
                const L = c_or / normFactor;
                const epsilon = (c_or - c_x) / normFactor;

                lines.push(`θ = 2 - log₂(3) = ${theta.toFixed(4)}`);
                lines.push(`cₒ,ᵣ = θ·o - r = ${c_or.toFixed(3)}`);
                lines.push(`cₓ = log₂(x) = ${c_x.toFixed(3)}`);
                lines.push(`L = cₒ,ᵣ/√(1+θ²) = ${L.toFixed(3)}`);
                lines.push(`ε = (cₒ,ᵣ-cₓ)/√(1+θ²) = ${epsilon.toFixed(3)}`);

                this.ctx.font = '14px monospace';
                const padding = 10;
                const lineHeight = 18;

                // Calculate box dimensions
                let boxWidth = 0;
                for (const line of lines) {
                    const metrics = this.ctx.measureText(line);
                    boxWidth = Math.max(boxWidth, metrics.width);
                }
                boxWidth += padding * 2;
                const boxHeight = lines.length * lineHeight + padding * 2;

                // Position tooltip in top-left corner
                const tooltipX = 10;
                const tooltipY = 10;

                // Draw box background
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                this.ctx.fillRect(tooltipX, tooltipY, boxWidth, boxHeight);

                // Draw box border
                this.ctx.strokeStyle = '#ffff00';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(tooltipX, tooltipY, boxWidth, boxHeight);

                // Draw text lines
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = '14px monospace';
                this.ctx.textAlign = 'left';
                this.ctx.textBaseline = 'top';

                let currentY = tooltipY + padding;
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];

                    // Center the block pattern if it exists (first line)
                    if (i === 0 && blockPattern) {
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(line, tooltipX + boxWidth / 2, currentY);
                        this.ctx.textAlign = 'left';
                    } else {
                        this.ctx.fillText(line, tooltipX + padding, currentY);
                    }

                    currentY += lineHeight;
                }
            }
        }

        // Heatmap renderer for (β, α) distribution
        class HeatmapRenderer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.distribution = null;
            }

            clear() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.distribution = null;
            }

            render(sequence) {
                this.distribution = sequence.getAlphaBetaDistribution();
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                if (this.distribution.length === 0) return;

                // Find bounds
                const betaValues = this.distribution.map(d => d.beta);
                const alphaValues = this.distribution.map(d => d.alpha);
                const counts = this.distribution.map(d => d.count);
                const minBeta = Math.min(...betaValues);
                const maxBeta = Math.max(...betaValues);
                const minAlpha = Math.min(...alphaValues);
                const maxAlpha = Math.max(...alphaValues);
                const maxCount = Math.max(...counts);

                // Add padding
                const padding = 60;
                const plotWidth = this.canvas.width - padding * 2;
                const plotHeight = this.canvas.height - padding * 2;

                // Calculate scale - α on x-axis, β on y-axis
                const alphaRange = maxAlpha - minAlpha || 1;
                const betaRange = maxBeta - minBeta || 1;
                const scaleX = plotWidth / alphaRange;
                const scaleY = plotHeight / betaRange;

                // Helper function to convert α,β to screen coordinates
                const toScreenX = (alpha) => padding + (alpha - minAlpha) * scaleX;
                const toScreenY = (beta) => this.canvas.height - padding - (beta - minBeta) * scaleY;

                // Draw axes
                this.ctx.strokeStyle = '#666';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(padding, this.canvas.height - padding);
                this.ctx.lineTo(this.canvas.width - padding, this.canvas.height - padding);
                this.ctx.moveTo(padding, this.canvas.height - padding);
                this.ctx.lineTo(padding, padding);
                this.ctx.stroke();

                // Draw axis labels
                this.ctx.fillStyle = '#e0e0e0';
                this.ctx.font = '16px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('α = v₂(x+1)', this.canvas.width / 2, this.canvas.height - 10);
                this.ctx.save();
                this.ctx.translate(15, this.canvas.height / 2);
                this.ctx.rotate(-Math.PI / 2);
                this.ctx.fillText('β = v₂(x)', 0, 0);
                this.ctx.restore();

                // Draw grid lines and labels
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 0.5;
                this.ctx.font = '12px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillStyle = '#999';

                // α axis ticks (x-axis)
                for (let alpha = minAlpha; alpha <= maxAlpha; alpha++) {
                    const x = toScreenX(alpha);
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, padding);
                    this.ctx.lineTo(x, this.canvas.height - padding);
                    this.ctx.stroke();
                    this.ctx.fillText(alpha.toString(), x, this.canvas.height - padding + 20);
                }

                // β axis ticks (y-axis)
                this.ctx.textAlign = 'right';
                for (let beta = minBeta; beta <= maxBeta; beta++) {
                    const y = toScreenY(beta);
                    this.ctx.beginPath();
                    this.ctx.moveTo(padding, y);
                    this.ctx.lineTo(this.canvas.width - padding, y);
                    this.ctx.stroke();
                    this.ctx.fillText(beta.toString(), padding - 10, y + 4);
                }

                // Draw bubbles
                for (const point of this.distribution) {
                    const x = toScreenX(point.alpha);
                    const y = toScreenY(point.beta);

                    // Size proportional to count (like matplotlib s=count*20)
                    const baseRadius = Math.sqrt(point.count * 20);
                    const radius = Math.min(baseRadius, 50); // Cap maximum size

                    // Color based on count (viridis-like colormap)
                    const normalized = point.count / maxCount;
                    const color = this.viridisColor(normalized);

                    // Draw circle
                    this.ctx.fillStyle = color;
                    this.ctx.globalAlpha = 0.7;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius, 0, 2 * Math.PI);
                    this.ctx.fill();

                    // Draw border
                    this.ctx.strokeStyle = '#000';
                    this.ctx.lineWidth = 1;
                    this.ctx.globalAlpha = 1.0;
                    this.ctx.stroke();

                    // Draw count label for larger bubbles
                    if (radius > 10) {
                        this.ctx.fillStyle = '#fff';
                        this.ctx.font = 'bold 12px sans-serif';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText(point.count.toString(), x, y);
                    }
                }

                this.ctx.globalAlpha = 1.0;

                // Draw title
                this.ctx.fillStyle = '#e0e0e0';
                this.ctx.font = 'bold 16px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('(α, β) Distribution', this.canvas.width / 2, 25);
            }

            // Viridis-inspired colormap
            viridisColor(t) {
                // Simplified viridis: interpolate between purple, blue, green, yellow
                t = Math.max(0, Math.min(1, t)); // Clamp to [0,1]

                if (t < 0.25) {
                    const s = t / 0.25;
                    return this.rgbToHex(68 + s * (59 - 68), 1 + s * (82 - 1), 84 + s * (139 - 84));
                } else if (t < 0.5) {
                    const s = (t - 0.25) / 0.25;
                    return this.rgbToHex(59 + s * (33 - 59), 82 + s * (145 - 82), 139 + s * (140 - 139));
                } else if (t < 0.75) {
                    const s = (t - 0.5) / 0.25;
                    return this.rgbToHex(33 + s * (94 - 33), 145 + s * (201 - 145), 140 + s * (98 - 140));
                } else {
                    const s = (t - 0.75) / 0.25;
                    return this.rgbToHex(94 + s * (253 - 94), 201 + s * (231 - 201), 98 + s * (37 - 98));
                }
            }

            rgbToHex(r, g, b) {
                r = Math.round(r);
                g = Math.round(g);
                b = Math.round(b);
                return `rgb(${r}, ${g}, ${b})`;
            }
        }

        // Main application
        class Application {
            constructor() {
                this.renderer = new LatticeRenderer('latticeCanvas');
                this.heatmapRenderer = new HeatmapRenderer('heatmapCanvas');
                this.currentSequence = null;
                this.isInitialLoad = true;

                // Set up double-click handler
                this.renderer.onPointDoubleClick = (x) => {
                    this.loadSequenceForX(x);
                };

                // Set up animation complete handler
                this.renderer.onAnimationComplete = () => {
                    this.updateAnimateButton();
                };

                // Handle browser back/forward buttons
                window.addEventListener('popstate', (e) => {
                    // Get x value from state or URL
                    let x;
                    if (e.state && e.state.x) {
                        x = e.state.x;
                    } else {
                        const urlParams = new URLSearchParams(window.location.search);
                        x = parseInt(urlParams.get('x')) || 27;
                    }

                    document.getElementById('x0Input').value = x;
                    // Don't update history when handling popstate
                    this.isInitialLoad = true;
                    this.plotSequence();
                    this.isInitialLoad = false;
                });

                this.loadFromURL();
            }

            loadFromURL() {
                // Read x from query string
                const urlParams = new URLSearchParams(window.location.search);
                const xParam = urlParams.get('x');
                if (xParam) {
                    const x = parseInt(xParam);
                    if (!isNaN(x) && x > 0) {
                        document.getElementById('x0Input').value = x;
                    }
                }
            }

            updateURL(x) {
                // Update URL without reloading the page, storing state for back button
                const url = new URL(window.location);
                url.searchParams.set('x', x);

                if (this.isInitialLoad) {
                    // Replace state on initial load to avoid creating extra history entry
                    window.history.replaceState({ x: x }, '', url);
                } else {
                    // Push new state for user-initiated changes
                    window.history.pushState({ x: x }, '', url);
                }
            }

            showError(message) {
                const errorPanel = document.getElementById('errorPanel');
                errorPanel.textContent = message;
                errorPanel.style.display = 'block';
                setTimeout(() => {
                    errorPanel.style.display = 'none';
                }, 5000);
            }

            updateInfo(sequence) {
                document.getElementById('oeSequence').textContent = sequence.getOEString();
                document.getElementById('seqLength').textContent = sequence.steps.length - 1; // Exclude start

                // Display OE blocks - each on its own line with initial x value
                const blocks = sequence.findOEBlocks();
                if (blocks.length > 0) {
                    const blockLines = blocks.map((b, i) => {
                        const startX = sequence.steps[b.start].x;
                        return `x=${startX}: ${b.pattern}`;
                    });
                    document.getElementById('oeBlocks').textContent = blockLines.join('\n');
                } else {
                    document.getElementById('oeBlocks').textContent = 'None found';
                }

                // Update x₀ info panel
                this.updateX0Info(sequence);

                // Verify invariants
                this.verifyInvariants(sequence);
            }

            updateX0Info(sequence) {
                const step = sequence.steps[0]; // x₀
                const theta = 2 - Math.log2(3);
                const c_or = theta * step.o - step.r;
                const c_x = Math.log2(step.x);
                const normFactor = Math.sqrt(1 + theta * theta);
                const L = c_or / normFactor;
                const epsilon = (c_or - c_x) / normFactor;

                const lines = [];
                lines.push(`x = ${step.x}`);
                lines.push(`o = ${step.o}, r = ${step.r}, e = ${step.e}`);
                lines.push(`α = ${step.alpha}, γ = ${step.gamma}, β = ${step.beta}`);
                lines.push(`m = ${step.m.toFixed(4)}`);
                lines.push(`λₓ = log₂(x) = ${step.lambda_x.toFixed(4)}`);
                lines.push(`λₘ = log₃(m) = ${step.lambda_m.toFixed(4)}`);
                lines.push(`d = 2^(2o-r) - 3^o = ${step.d}`);
                lines.push(`k = 2^e - 3^o·x = ${step.k}`);
                lines.push(`λₖ = log₂(k) = ${step.lambda_k.toFixed(4)}`);
                lines.push(`θ = 2 - log₂(3) = ${theta.toFixed(4)}`);
                lines.push(`cₒ,ᵣ = θ·o - r = ${c_or.toFixed(3)}`);
                lines.push(`cₓ = log₂(x) = ${c_x.toFixed(3)}`);
                lines.push(`L = cₒ,ᵣ/√(1+θ²) = ${L.toFixed(3)}`);
                lines.push(`ε = (cₒ,ᵣ-cₓ)/√(1+θ²) = ${epsilon.toFixed(3)}`);

                document.getElementById('infoContent').textContent = lines.join('\n');
                document.getElementById('infoPanel').style.display = 'block';
            }

            verifyInvariants(sequence) {
                const distribution = sequence.getAlphaBetaDistribution();
                const finalStep = sequence.steps[0]; // Initial step has the final o, r values

                // Invariant 1: sum(count for cells where α=1) should equal o
                let sumAlpha1 = 0;
                for (const point of distribution) {
                    if (point.alpha === 1) {
                        sumAlpha1 += point.count;
                    }
                }

                // Invariant 2: sum(count * (α-2) for cells where β=1) should equal r
                let sumBeta1 = 0;
                for (const point of distribution) {
                    if (point.beta === 1) {
                        sumBeta1 += point.count * (point.alpha - 2);
                    }
                }

                console.log('=== Invariant Check ===');
                console.log(`x0 = ${sequence.x0}`);
                console.log(`Final o = ${finalStep.o}, r = ${finalStep.r}`);
                console.log(`Invariant 1: sum(count for α=1) = ${sumAlpha1}, expected o = ${finalStep.o}, ✓=${sumAlpha1 === finalStep.o}`);
                console.log(`Invariant 2: sum(count * (α-2) for β=1) = ${sumBeta1}, expected r = ${finalStep.r}, ✓=${sumBeta1 === finalStep.r}`);
                console.log('Distribution:', distribution);
            }

            plotSequence() {
                try {
                    const x0 = parseInt(document.getElementById('x0Input').value);
                    if (isNaN(x0) || x0 < 1) {
                        this.showError('Please enter a valid positive integer');
                        return;
                    }

                    const sequence = new CollatzSequence(x0);
                    this.currentSequence = sequence;
                    this.renderer.clear();
                    this.renderer.addSequence(sequence);
                    this.heatmapRenderer.render(sequence);
                    this.updateInfo(sequence);

                    // Update URL to reflect current x value
                    this.updateURL(x0);

                } catch (error) {
                    this.showError(error.message);
                    console.error(error);
                }
            }

            loadSequenceForX(x) {
                // Called when double-clicking a lattice point
                document.getElementById('x0Input').value = x;
                this.plotSequence();
            }

            clearCanvas() {
                this.renderer.clear();
                this.heatmapRenderer.clear();
                this.currentSequence = null;
                document.getElementById('oeSequence').textContent = '-';
                document.getElementById('seqLength').textContent = '-';
                document.getElementById('oeBlocks').textContent = '-';
                document.getElementById('infoPanel').style.display = 'none';
            }

            loadExample(x0) {
                document.getElementById('x0Input').value = x0;
                this.plotSequence();
            }

            toggleEvenTerms() {
                const showEven = document.getElementById('showEvenTerms').checked;
                this.renderer.showEvenTerms = showEven;
                this.renderer.fitToView();
                this.renderer.render();
            }

            toggleLayer(layerName) {
                const layer = this.renderer.findLayer(layerName);
                if (layer) {
                    layer.enabled = !layer.enabled;
                    this.renderer.render();
                    this.updateAnimateButton();
                }
            }

            toggleAnimation() {
                this.renderer.startAnimation();
            }

            updateAnimateButton() {
                const xValueLayer = this.renderer.findLayer('X Values');
                const button = document.getElementById('animateButton');

                if (xValueLayer && xValueLayer.enabled) {
                    button.style.display = 'inline-block';
                    // Update button text based on animation state
                    if (this.renderer.animationT >= 1) {
                        button.textContent = 'Animate to (o,r)';
                    } else {
                        button.textContent = 'Animate to λₓ';
                    }
                } else {
                    button.style.display = 'none';
                }
            }
        }

        // Initialize application
        const app = new Application();

        // Plot default example on load
        window.addEventListener('load', () => {
            app.plotSequence();
            app.isInitialLoad = false;
            app.updateAnimateButton();
        });
    </script>
</body>
</html>
