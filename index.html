<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>O-R Lattice: Collatz Sequence Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2em;
            margin-bottom: 10px;
            color: #4a9eff;
        }

        .subtitle {
            color: #999;
            font-size: 0.9em;
        }

        .controls {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .control-row {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        label {
            font-weight: 500;
            min-width: 80px;
        }

        input[type="number"],
        input[type="text"] {
            background: #1a1a1a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 1em;
            width: 200px;
        }

        input[type="number"]:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: #4a9eff;
        }

        button {
            background: #4a9eff;
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 4px;
            font-size: 1em;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }

        button:hover {
            background: #3a8eef;
        }

        button:active {
            background: #2a7edf;
        }

        .canvas-container {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            overflow: auto;
        }

        canvas {
            display: block;
            background: #1a1a1a;
            border: 1px solid #444;
            cursor: crosshair;
        }

        .info-panel {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .info-section {
            margin-bottom: 15px;
        }

        .info-section:last-child {
            margin-bottom: 0;
        }

        .info-label {
            font-weight: 500;
            color: #4a9eff;
            margin-bottom: 5px;
        }

        .info-value {
            font-family: 'Courier New', monospace;
            color: #e0e0e0;
            padding: 8px;
            background: #1a1a1a;
            border-radius: 4px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .congruence-link {
            color: #4a9eff;
            text-decoration: none;
            cursor: pointer;
            padding: 0 2px;
        }

        .congruence-link:hover {
            color: #6bb3ff;
            text-decoration: underline;
        }

        .congruence-link:active {
            color: #88c5ff;
        }

        .anchor-section {
            margin-top: 10px;
            padding: 10px 15px;
            background: #333;
            border-radius: 4px;
            border: 1px solid #4a9eff;
        }

        .anchor-label {
            font-weight: 500;
            color: #4a9eff;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .anchor-content {
            display: flex;
            gap: 20px;
            font-family: 'Courier New', monospace;
            color: #e0e0e0;
        }

        .anchor-nav {
            margin-top: 8px;
            font-family: 'Courier New', monospace;
            color: #e0e0e0;
        }

        canvas {
            user-select: none;
        }

        .error {
            background: #4a1a1a;
            color: #ff6b6b;
            padding: 10px 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            border: 1px solid #ff6b6b;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>O-R Lattice: Collatz Sequence Visualizer</h1>
            <div class="subtitle">Explore 3x+1 sequences through the (o,r) coordinate system</div>
        </header>

        <div class="controls">
            <div class="control-row">
                <label for="x0Input">Starting value (x₀):</label>
                <input type="number" id="x0Input" value="27" min="1" step="1">
                <button onclick="app.anchor_k = null; app.plotSequence()">Plot Sequence</button>
                <button onclick="app.clearCanvas()">Clear</button>
            </div>
            <div class="control-row">
                <label>Examples:</label>
                <button onclick="app.loadExample(27)">27</button>
                <button onclick="app.loadExample(31)">31</button>
                <button onclick="app.loadExample(63)">63</button>
                <button onclick="app.loadExample(127)">127</button>
                <button onclick="app.loadExample(70055)">70055</button>
                <button onclick="app.loadExample(77031)">77031</button>
            </div>
            <div class="control-row">
                <label>
                    <input type="checkbox" id="showEvenTerms" onchange="app.toggleEvenTerms()">
                    Show even terms on lattice
                </label>
            </div>
            <div class="control-row">
                <label>Layers:</label>
                <label><input type="checkbox" id="layerGrid" checked onchange="app.toggleLayer('Grid')"> Grid</label>
                <label><input type="checkbox" id="layerAxes" checked onchange="app.toggleLayer('Axes')"> Axes</label>
                <label><input type="checkbox" id="layerPath" checked onchange="app.toggleLayer('Path')"> Path</label>
                <label><input type="checkbox" id="layerBlocks" onchange="app.toggleLayer('OE Blocks')"> OE Blocks</label>
                <label><input type="checkbox" id="layerXValue" checked onchange="app.toggleLayer('X Values')"> λₓ-layer</label>
                <label><input type="checkbox" id="layerEpsilon" onchange="app.toggleLayer('Epsilon')"> ε-layer</label>
                <button id="animateButton" onclick="app.toggleAnimation()" style="margin-left: 20px;">Animate to λₓ</button>
            </div>
        </div>

        <div id="errorPanel" class="error" style="display: none;"></div>

        <div class="canvas-container">
            <canvas id="latticeCanvas" width="1200" height="800"></canvas>
        </div>

        <div id="anchorSection" class="anchor-section" style="display: none;">
            <div class="anchor-label">Anchor</div>
            <div class="anchor-content">
                <span id="anchorK">k = -</span>
                <span id="anchorOEPrefix">-</span>
            </div>
            <div class="anchor-nav" id="anchorNav"></div>
        </div>

        <div id="infoPanel" class="info-panel" style="display: none;">
            <div class="info-section">
                <div class="info-label">Starting Value (x₀)</div>
                <div class="info-value" id="infoContent"></div>
            </div>
        </div>

        <div class="info-panel">
            <div class="info-section">
                <div class="info-label">Sequence (OE notation):</div>
                <div id="oeSequence" class="info-value">-</div>
            </div>
            <div class="info-section">
                <div class="info-label">Sequence length:</div>
                <div id="seqLength" class="info-value">-</div>
            </div>
            <div class="info-section">
                <div class="info-label">((OE)+E+) blocks:</div>
                <div id="oeBlocks" class="info-value">-</div>
            </div>
        </div>

        <div class="canvas-container">
            <h2 style="color: #4a9eff; margin-bottom: 15px;">Heatmap: (α, β) Distribution</h2>
            <div style="color: #999; margin-bottom: 10px; font-size: 0.9em;">
                For odd x: α = v₂(x+1), β = v₂(3x+1)
            </div>
            <canvas id="heatmapCanvas" width="800" height="600"></canvas>
        </div>

    </div>

    <script>
        // Configuration
        const CONFIG = {
            maxIterations: 10000,
            gridSize: 20,
            pointRadius: 4,
            lineWidth: 2,
            colors: {
                oddStep: '#ff6b6b',    // Red for O steps (3x+1)
                evenStep: '#4a9eff',   // Blue for E steps (x/2)
                grid: '#333',
                axes: '#666',
                point: '#fff',
                blocks: [
                    '#ff00ff',  // Magenta
                    '#00ffff',  // Cyan
                    '#ffff00',  // Yellow
                    '#00ff00',  // Green
                    '#ff8800',  // Orange
                    '#8800ff',  // Purple
                    '#ff0088',  // Pink
                    '#88ff00',  // Lime
                ]
            }
        };

        // Collatz sequence computation with (o, e, r) tracking
        class CollatzSequence {
            constructor(x0) {
                this.x0 = x0;
                this.steps = [];
                this.sortedByL = null;  // Sorted index for descent term search
                this.compute();
                this.buildLIndex();  // Build L-index after computing sequence
            }

            compute() {
                // First, compute the sequence forward to get x values and types
                let x = this.x0;
                let tempSteps = [{ x: x, type: 'start' }];

                let iterations = 0;
                while (x !== 1 && iterations < CONFIG.maxIterations) {
                    if (x % 2 === 1) {
                        // Odd step: 3x+1
                        x = 3 * x + 1;
                        tempSteps.push({ x: x, type: 'O' });
                    } else {
                        // Even step: x/2
                        x = x / 2;
                        tempSteps.push({ x: x, type: 'E' });
                    }
                    iterations++;
                }

                if (iterations >= CONFIG.maxIterations) {
                    throw new Error(`Sequence did not reach 1 within ${CONFIG.maxIterations} iterations`);
                }

                // Now compute o, e, r, α, β, γ backwards from x=1 (where o=0, e=0)
                // Start from the end and work backwards
                for (let i = tempSteps.length - 1; i >= 0; i--) {
                    const currentX = tempSteps[i].x;

                    // Compute α = v₂(x+1)
                    tempSteps[i].alpha = this.v2(currentX + 1);

                    // Compute m = (x+1) / 2^α
                    tempSteps[i].m = (currentX + 1) / Math.pow(2, tempSteps[i].alpha);

                    // Compute β = v₂(3^α · m - 1)
                    const threePowAlpha = Math.pow(3, tempSteps[i].alpha);
                    tempSteps[i].beta = this.v2(threePowAlpha * tempSteps[i].m - 1);

                    // Compute γ = v₃(m mod 2^(β+1))
                    const twoPowBetaPlusOne = Math.pow(2, tempSteps[i].beta + 1);
                    const mMod = tempSteps[i].m % twoPowBetaPlusOne;
                    tempSteps[i].gamma = this.v3(mMod);

                    // Compute lambda_x = log_2(x)
                    tempSteps[i].lambda_x = Math.log2(currentX);

                    if (i === tempSteps.length - 1) {
                        // At x=1: o=0, e=0
                        tempSteps[i].o = 0;
                        tempSteps[i].e = 0;
                        tempSteps[i].r = 0;
                        tempSteps[i].n = i;
                    } else {
                        // Get successor (next step in forward direction)
                        const successor = tempSteps[i + 1];

                        // If current x is odd, o = successor.o + 1, e = successor.e
                        // If current x is even, o = successor.o, e = successor.e + 1
                        if (currentX % 2 === 1) {
                            tempSteps[i].o = successor.o + 1;
                            tempSteps[i].e = successor.e;
                        } else {
                            tempSteps[i].o = successor.o;
                            tempSteps[i].e = successor.e + 1;
                        }

                        tempSteps[i].r = 2 * tempSteps[i].o - tempSteps[i].e;
                        tempSteps[i].n = i;
                    }

                    // Compute d = 2^(2o-r) - 3^o (after o and r are set)
                    tempSteps[i].d = Math.pow(2, 2 * tempSteps[i].o - tempSteps[i].r) - Math.pow(3, tempSteps[i].o);

                    // Compute k = 2^e - 3^o * x (after o and e are set)
                    tempSteps[i].k = Math.pow(2, tempSteps[i].e) - Math.pow(3, tempSteps[i].o) * currentX;

                    // Compute lambda_k = log_2(k)
                    tempSteps[i].lambda_k = Math.log2(Math.abs(tempSteps[i].k));

                    // For even x, compute ν = v₂(x) and work with odd part
                    // For odd x, ν = 0
                    if (currentX % 2 === 0) {
                        tempSteps[i].nu = this.v2(currentX);
                        const xOdd = currentX / Math.pow(2, tempSteps[i].nu);
                        // Compute parameters based on odd part
                        const alphaOdd = this.v2(xOdd + 1);
                        const mOdd = (xOdd + 1) / Math.pow(2, alphaOdd);
                        const threePowAlphaOdd = Math.pow(3, alphaOdd);
                        const betaOdd = this.v2(threePowAlphaOdd * mOdd - 1);
                        const twoPowBetaOddPlusOne = Math.pow(2, betaOdd + 1);
                        const mOddMod = mOdd % twoPowBetaOddPlusOne;
                        const gammaOdd = this.v3(mOddMod);
                        // ρ = (m mod 2^(β+1)) / 3^γ
                        tempSteps[i].rho = mOddMod / Math.pow(3, gammaOdd);
                        // t = floor(m / 2^(β+1))
                        tempSteps[i].t = Math.floor(mOdd / twoPowBetaOddPlusOne);
                    } else {
                        tempSteps[i].nu = 0;
                        // Compute ρ and t from m = 3^γ·ρ + t·2^(β+1)
                        // ρ = (m mod 2^(β+1)) / 3^γ
                        tempSteps[i].rho = mMod / Math.pow(3, tempSteps[i].gamma);
                        // t = floor(m / 2^(β+1))
                        tempSteps[i].t = Math.floor(tempSteps[i].m / twoPowBetaPlusOne);
                    }
                }

                this.steps = tempSteps;
            }

            buildLIndex() {
                // Build sorted index for efficient descent term search
                // Compute L for each step and create sorted array
                const theta = 2 - Math.log2(3);
                const normFactor = Math.sqrt(1 + theta * theta);

                // Create array of {step, L, o} tuples
                const indexEntries = this.steps.map(step => {
                    const c_or = theta * step.o - step.r;
                    const L = c_or / normFactor;
                    return { step, L, o: step.o };
                });

                // Sort by (L, o) ascending
                this.sortedByL = indexEntries.sort((a, b) => {
                    if (a.L !== b.L) return a.L - b.L;
                    return a.o - b.o;
                });
            }

            findFirstDescentTerm(searchStep) {
                // Find the first descent term where:
                // 1. x < x_search
                // 2. L < L_search
                // 3. o < o_search
                // Among all candidates, return the one with LARGEST o (closest to o_search from below)

                if (!this.sortedByL || this.sortedByL.length === 0) return null;

                const theta = 2 - Math.log2(3);
                const normFactor = Math.sqrt(1 + theta * theta);
                const c_or = theta * searchStep.o - searchStep.r;
                const searchL = c_or / normFactor;
                const searchO = searchStep.o;
                const searchX = searchStep.x;

                console.log(`Searching for descent term of x=${searchX}, o=${searchO}, L=${searchL.toFixed(3)}`);

                // Binary search to find the rightmost entry with L < searchL
                // This gives us the largest L that is still less than searchL
                let left = 0;
                let right = this.sortedByL.length - 1;
                let candidateIdx = -1;

                while (left <= right) {
                    const mid = Math.floor((left + right) / 2);

                    if (this.sortedByL[mid].L < searchL) {
                        // This could be a candidate, but check if there's a larger L < searchL
                        candidateIdx = mid;
                        left = mid + 1;  // Look for larger L values
                    } else {
                        right = mid - 1;  // L is too large, search left
                    }
                }

                // Now search backward from candidateIdx to find the best match
                // We want: L < searchL, o < searchO, x < searchX, and maximize o
                let bestCandidate = null;
                let bestO = -Infinity;

                // Search from candidateIdx backward (decreasing L)
                for (let i = candidateIdx; i >= 0; i--) {
                    const entry = this.sortedByL[i];

                    // Check all three conditions
                    if (entry.L < searchL && entry.o < searchO && entry.step.x < searchX) {
                        if (entry.o > bestO) {
                            bestO = entry.o;
                            bestCandidate = entry.step;
                        }
                    }
                }

                if (bestCandidate) {
                    const c_or_descent = theta * bestCandidate.o - bestCandidate.r;
                    const L_descent = c_or_descent / normFactor;
                    console.log(`  -> Found descent term: x=${bestCandidate.x}, o=${bestCandidate.o}, L=${L_descent.toFixed(3)}`);
                } else {
                    console.log(`  -> No descent term found (no step satisfying all conditions)`);
                }

                return bestCandidate;
            }

            // Compute v_2(n) - the 2-adic valuation (power of 2 dividing n)
            v2(n) {
                if (n === 0) return Infinity;
                let count = 0;
                while (n % 2 === 0) {
                    count++;
                    n = n / 2;
                }
                return count;
            }

            // Compute v_3(n) - the 3-adic valuation (power of 3 dividing n)
            v3(n) {
                if (n === 0) return Infinity;
                let count = 0;
                while (n % 3 === 0) {
                    count++;
                    n = n / 3;
                }
                return count;
            }

            getOEString() {
                return this.steps
                    .filter(s => s.type !== 'start')
                    .map(s => s.type)
                    .join('');
            }

            getBounds() {
                const oValues = this.steps.map(s => s.o);
                const rValues = this.steps.map(s => s.r);
                return {
                    minO: Math.min(...oValues),
                    maxO: Math.max(...oValues),
                    minR: Math.min(...rValues),
                    maxR: Math.max(...rValues)
                };
            }

            findOEBlocks() {
                // Find blocks matching ((OE)+E+) pattern
                const oeString = this.getOEString();
                const blocks = [];
                let i = 0;

                while (i < oeString.length) {
                    // Check if we're starting an (OE)+ sequence
                    if (i < oeString.length - 1 && oeString[i] === 'O' && oeString[i + 1] === 'E') {
                        const blockStart = i;

                        // Count (OE)+ pairs
                        while (i < oeString.length - 1 && oeString[i] === 'O' && oeString[i + 1] === 'E') {
                            i += 2;
                        }

                        // Mark where (OE)+ ends - this is the last E in the OE pairs
                        const oeEndIndex = i - 1;

                        // Check for E+ following the (OE)+ sequence
                        const eStart = i;
                        while (i < oeString.length && oeString[i] === 'E') {
                            i++;
                        }

                        // Only count as a block if we have at least one E after (OE)+
                        if (i > eStart) {
                            blocks.push({
                                start: blockStart,
                                end: i - 1,
                                oeEndIndex: oeEndIndex,  // Index of last E in (OE)+
                                pattern: oeString.substring(blockStart, i)
                            });
                        }
                    } else {
                        i++;
                    }
                }

                return blocks;
            }

            getAlphaBetaDistribution() {
                // Count occurrences of each (β, α) pair for ODD x values only
                const counts = new Map();

                for (const step of this.steps) {
                    // Only include odd x values (matching Python: if s.x%2==1)
                    if (step.x % 2 === 1) {
                        const key = `${step.beta},${step.alpha}`;
                        counts.set(key, (counts.get(key) || 0) + 1);
                    }
                }

                // Convert to array of {beta, alpha, count}
                const distribution = [];
                for (const [key, count] of counts.entries()) {
                    const [beta, alpha] = key.split(',').map(Number);
                    distribution.push({ beta, alpha, count });
                }

                return distribution;
            }

            getBlockForStep(stepIndex) {
                // Find which ((OE)+E+) block contains this step
                // A block with OE indices [start, end] includes:
                // - steps[start]: the starting odd term (before first transition)
                // - steps[start+1] through steps[end+1]: the transitions
                // So the block spans steps[start] through steps[end+1]

                const blocks = this.findOEBlocks();

                for (const block of blocks) {
                    // Check if stepIndex is within this block's range
                    if (stepIndex >= block.start && stepIndex <= block.end + 1) {
                        return block.pattern;
                    }
                }

                return null;
            }

            getOEBlockK(block) {
                // Get k value for OE block congruence
                // k = number of even terms in the block
                let k = 0;
                for (const char of block.pattern) {
                    if (char === 'E') k++;
                }
                return k;
            }

            getFirstDescentK(step) {
                // Get k value for first descent congruence
                // k = 2(o_x - o_fd) - (r_x - r_fd)
                const descentTerm = this.findFirstDescentTerm(step);
                if (!descentTerm) return null;

                const k = 2 * (step.o - descentTerm.o) - (step.r - descentTerm.r);
                return k;
            }

            getCongruences(x, k) {
                // Get congruence values x±2^k
                const power = Math.pow(2, k);
                const prev = x - power;
                const next = x + power;
                return {
                    prev: prev > 0 ? prev : null,
                    current: x,
                    next: next,
                    k: k
                };
            }

            getOEPrefixWithKEvens(k) {
                // Extract OE prefix with exactly k E's from the sequence
                const oeString = this.getOEString();
                let evenCount = 0;
                let prefix = '';

                for (let i = 0; i < oeString.length; i++) {
                    prefix += oeString[i];
                    if (oeString[i] === 'E') {
                        evenCount++;
                        if (evenCount === k) {
                            break;
                        }
                    }
                }

                return prefix;
            }

            getLastEvenInOEPlusIndices() {
                // Returns step indices of the last even term in each (OE)+ sequence
                // These should be shown even when "Show even terms" is unchecked
                const blocks = this.findOEBlocks();
                const indices = [];

                for (const block of blocks) {
                    // oeEndIndex is the OE string index of the last E in (OE)+
                    // Convert to step index: oeEndIndex + 1 (since steps[0] is start)
                    const stepIndex = block.oeEndIndex + 1;
                    indices.push(stepIndex);
                }

                return indices;
            }
        }

        // Utility functions for congruence display

        // Format congruence display as clickable HTML for info panels
        function formatCongruenceHTML(congruences) {
            const { prev, current, next, k } = congruences;
            let parts = [`k=${k}:`];

            if (prev) {
                parts.push(`<a href="?x=${prev}&anchor_k=${k}" class="congruence-link">←</a>`);
                parts.push(`<a href="?x=${prev}&anchor_k=${k}" class="congruence-link">${prev}</a>`);
            }

            parts.push('|');
            parts.push(`<strong>${current}</strong>`);  // Current not linked
            parts.push('|');

            if (next) {
                parts.push(`<a href="?x=${next}&anchor_k=${k}" class="congruence-link">${next}</a>`);
                parts.push(`<a href="?x=${next}&anchor_k=${k}" class="congruence-link">→</a>`);
            }

            return parts.join(' ');
        }

        // Format congruence display as plain text for canvas tooltips
        function formatCongruenceText(congruences) {
            const { prev, current, next, k } = congruences;
            let parts = [`k=${k}:`];

            if (prev) parts.push(`← ${prev}`);
            parts.push(`| ${current} |`);
            if (next) parts.push(`${next} →`);

            return parts.join(' ');
        }

        // Base Layer class for rendering system
        class Layer {
            constructor(name, enabled = true) {
                this.name = name;
                this.enabled = enabled;
                this.usesRightAxis = false;
                this.rightAxisLabel = '';
            }

            render(ctx, sequences, latticeTransform, rightAxisTransform = null) {
                // Override in subclasses
            }

            getRightAxisBounds(sequences) {
                // Override if usesRightAxis = true
                return null;
            }
        }

        // Grid layer - background grid lines
        class GridLayer extends Layer {
            constructor(enabled = true) {
                super('Grid', enabled);
            }

            render(ctx, sequences, latticeTransform) {
                if (sequences.length === 0) return;

                // Calculate bounds from visible steps
                let minO = Infinity, maxO = -Infinity;
                let minR = Infinity, maxR = -Infinity;

                for (const seq of sequences) {
                    const visibleSteps = latticeTransform.getVisibleSteps(seq);
                    for (const step of visibleSteps) {
                        minO = Math.min(minO, step.o);
                        maxO = Math.max(maxO, step.o);
                        minR = Math.min(minR, step.r);
                        maxR = Math.max(maxR, step.r);
                    }
                }

                minO = Math.floor(minO) - 2;
                maxO = Math.ceil(maxO) + 2;
                minR = Math.floor(minR) - 2;
                maxR = Math.ceil(maxR) + 2;

                ctx.strokeStyle = CONFIG.colors.grid;
                ctx.lineWidth = 0.5;

                // Vertical grid lines (constant o)
                for (let o = minO; o <= maxO; o++) {
                    const x = latticeTransform.toScreenX(o);
                    ctx.beginPath();
                    ctx.moveTo(x, latticeTransform.toScreenY(minR));
                    ctx.lineTo(x, latticeTransform.toScreenY(maxR));
                    ctx.stroke();
                }

                // Horizontal grid lines (constant r)
                for (let r = minR; r <= maxR; r++) {
                    const y = latticeTransform.toScreenY(r);
                    ctx.beginPath();
                    ctx.moveTo(latticeTransform.toScreenX(minO), y);
                    ctx.lineTo(latticeTransform.toScreenX(maxO), y);
                    ctx.stroke();
                }
            }
        }

        // Axes layer - O and R coordinate axes
        class AxesLayer extends Layer {
            constructor(enabled = true) {
                super('Axes', enabled);
            }

            render(ctx, sequences, latticeTransform) {
                if (sequences.length === 0) return;

                // Calculate bounds
                let minO = Infinity, maxO = -Infinity;
                let minR = Infinity, maxR = -Infinity;

                for (const seq of sequences) {
                    const visibleSteps = latticeTransform.getVisibleSteps(seq);
                    for (const step of visibleSteps) {
                        minO = Math.min(minO, step.o);
                        maxO = Math.max(maxO, step.o);
                        minR = Math.min(minR, step.r);
                        maxR = Math.max(maxR, step.r);
                    }
                }

                minO = Math.floor(minO) - 2;
                maxO = Math.ceil(maxO) + 2;
                minR = Math.floor(minR) - 2;
                maxR = Math.ceil(maxR) + 2;

                ctx.strokeStyle = CONFIG.colors.axes;
                ctx.lineWidth = 2;

                // O-axis (r = 0)
                if (minR <= 0 && maxR >= 0) {
                    const y = latticeTransform.toScreenY(0);
                    ctx.beginPath();
                    ctx.moveTo(latticeTransform.toScreenX(minO), y);
                    ctx.lineTo(latticeTransform.toScreenX(maxO), y);
                    ctx.stroke();
                }

                // R-axis (o = 0)
                if (minO <= 0 && maxO >= 0) {
                    const x = latticeTransform.toScreenX(0);
                    ctx.beginPath();
                    ctx.moveTo(x, latticeTransform.toScreenY(minR));
                    ctx.lineTo(x, latticeTransform.toScreenY(maxR));
                    ctx.stroke();
                }

                // Labels
                ctx.fillStyle = CONFIG.colors.axes;
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('o →', latticeTransform.toScreenX(maxO) - 20, latticeTransform.toScreenY(0) - 10);
                ctx.save();
                ctx.translate(latticeTransform.toScreenX(0) + 20, latticeTransform.toScreenY(maxR) + 20);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('r →', 0, 0);
                ctx.restore();
            }
        }

        // OE Blocks layer - ((OE)+E+) block visualization
        class OEBlocksLayer extends Layer {
            constructor(enabled = false) {
                super('OE Blocks', enabled);
            }

            render(ctx, sequences, latticeTransform) {
                for (const sequence of sequences) {
                    const blocks = sequence.findOEBlocks();

                    for (let blockIdx = 0; blockIdx < blocks.length; blockIdx++) {
                        const block = blocks[blockIdx];
                        const color = CONFIG.colors.blocks[blockIdx % CONFIG.colors.blocks.length];

                        const startStepIdx = block.start;
                        const endStepIdx = block.end + 1;
                        const blockSteps = sequence.steps.slice(startStepIdx, endStepIdx + 1);

                        if (blockSteps.length < 2) continue;

                        // Find bounding box
                        const oValues = blockSteps.map(s => s.o);
                        const rValues = blockSteps.map(s => s.r);
                        const minO = Math.min(...oValues);
                        const maxO = Math.max(...oValues);
                        const minR = Math.min(...rValues);
                        const maxR = Math.max(...rValues);

                        const padding = 10;
                        const x1 = latticeTransform.toScreenX(minO) - padding;
                        const y1 = latticeTransform.toScreenY(maxR) - padding;
                        const width = latticeTransform.toScreenX(maxO) - latticeTransform.toScreenX(minO) + padding * 2;
                        const height = latticeTransform.toScreenY(minR) - latticeTransform.toScreenY(maxR) + padding * 2;

                        // Draw semi-transparent box
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 3;
                        ctx.setLineDash([5, 5]);
                        ctx.strokeRect(x1, y1, width, height);
                        ctx.setLineDash([]);

                        ctx.fillStyle = color + '20';
                        ctx.fillRect(x1, y1, width, height);

                        // Label
                        ctx.fillStyle = color;
                        ctx.font = 'bold 12px sans-serif';
                        ctx.textAlign = 'left';
                        ctx.fillText(block.pattern, x1 + 5, y1 + 15);
                    }
                }
            }
        }

        // Path layer - sequence paths and points
        class PathLayer extends Layer {
            constructor(enabled = true) {
                super('Path', enabled);
            }

            render(ctx, sequences, latticeTransform) {
                const t = latticeTransform.animationT || 0;

                for (const sequence of sequences) {
                    // Get visible steps
                    const filteredSteps = latticeTransform.getVisibleSteps(sequence);

                    // Always draw original lattice at (o, r) in gold
                    // Draw edges
                    for (let i = 0; i < filteredSteps.length - 1; i++) {
                        const curr = filteredSteps[i];
                        const next = filteredSteps[i + 1];

                        const x1 = latticeTransform.toScreenX(curr.o);
                        const y1 = latticeTransform.toScreenY(curr.r);
                        const x2 = latticeTransform.toScreenX(next.o);
                        const y2 = latticeTransform.toScreenY(next.r);

                        ctx.strokeStyle = next.type === 'O' ? CONFIG.colors.oddStep : CONFIG.colors.evenStep;
                        ctx.lineWidth = CONFIG.lineWidth;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }

                    // Draw original points
                    for (let i = 0; i < filteredSteps.length; i++) {
                        const step = filteredSteps[i];
                        const x = latticeTransform.toScreenX(step.o);
                        const y = latticeTransform.toScreenY(step.r);

                        // Check if this step is the descent term - color it cyan
                        const isDescentTerm = latticeTransform.descentTerm && step.n === latticeTransform.descentTerm.n;
                        ctx.fillStyle = isDescentTerm ? 'rgba(0, 255, 255, 0.8)' : 'rgba(255, 215, 0, 0.6)';  // Cyan for descent, gold for others
                        ctx.beginPath();
                        ctx.arc(x, y, CONFIG.pointRadius, 0, 2 * Math.PI);
                        ctx.fill();

                        // Label start and end
                        if (i === 0 || i === filteredSteps.length - 1) {
                            ctx.fillStyle = '#fff';
                            ctx.font = 'bold 12px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.fillText(
                                i === 0 ? `Start (${step.x})` : `End (${step.x})`,
                                x,
                                y - 15
                            );
                        }
                    }

                    // If animating, draw animated copy morphing to (o, -log₂(x)) with color change
                    if (t > 0) {
                        // Interpolate color from gold to green
                        const r = Math.round(255 * (1 - t) + 50 * t);
                        const g = Math.round(215 * (1 - t) + 205 * t);
                        const b = Math.round(0 * (1 - t) + 50 * t);
                        const alpha = 0.6 * (1 - t) + 0.5 * t;

                        // Draw animated edges
                        for (let i = 0; i < filteredSteps.length - 1; i++) {
                            const curr = filteredSteps[i];
                            const next = filteredSteps[i + 1];

                            const x1 = latticeTransform.toScreenX(curr.o);
                            const y1 = latticeTransform.toScreenY(latticeTransform.getAnimatedY(curr));
                            const x2 = latticeTransform.toScreenX(next.o);
                            const y2 = latticeTransform.toScreenY(latticeTransform.getAnimatedY(next));

                            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                            ctx.lineWidth = CONFIG.lineWidth;

                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }

                        // Draw animated points
                        for (let i = 0; i < filteredSteps.length; i++) {
                            const step = filteredSteps[i];
                            const x = latticeTransform.toScreenX(step.o);
                            const y = latticeTransform.toScreenY(latticeTransform.getAnimatedY(step));

                            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                            ctx.beginPath();
                            ctx.arc(x, y, CONFIG.pointRadius, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                    }
                }
            }
        }

        // X Value layer - plots at (o, log₂(x)) on left axis with β as circle size
        // Also draws mirrored plot at (o, -log₂(x)) with fixed size and lower intensity
        class XValueLayer extends Layer {
            constructor(enabled = true) {
                super('X Values', enabled);
                this.usesRightAxis = false;
            }

            render(ctx, sequences, latticeTransform, rightAxisTransform) {
                const theta = 2 - Math.log2(3);

                // Determine which step should have the horizontal line
                const highlightStep = latticeTransform.hoveredPoint
                    ? latticeTransform.hoveredPoint.step
                    : latticeTransform.defaultStep;

                // Draw horizontal reference lines on log₂(x) graph corresponding to theta-slope lines
                // These lines correspond to the three theta-slope lines on the o-r lattice
                if (highlightStep && sequences.length > 0) {
                    // Get bounds for drawing lines across the canvas
                    let minO = Infinity, maxO = -Infinity;
                    for (const seq of sequences) {
                        const visibleSteps = latticeTransform.getVisibleSteps(seq);
                        for (const step of visibleSteps) {
                            minO = Math.min(minO, step.o);
                            maxO = Math.max(maxO, step.o);
                        }
                    }
                    minO = Math.floor(minO) - 2;
                    maxO = Math.ceil(maxO) + 2;

                    // Line 1: Orange - corresponds to x-estimator on o-r lattice
                    // O-R lattice: r = θ*o + c1, where c1 = r - θ*o
                    // Log₂(x) graph: y = -c1 = θ*o - r = cₒ,ᵣ
                    const c_or = theta * highlightStep.o - highlightStep.r;
                    ctx.strokeStyle = 'rgba(255, 140, 0, 0.6)';  // Match orange theta line
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([6, 3]);
                    ctx.beginPath();
                    ctx.moveTo(latticeTransform.toScreenX(minO), latticeTransform.toScreenY(c_or));
                    ctx.lineTo(latticeTransform.toScreenX(maxO), latticeTransform.toScreenY(c_or));
                    ctx.stroke();

                    // Line 2: Red-orange - corresponds to (o,r)-estimator on o-r lattice
                    // O-R lattice: r = θ*o + c2, where c2 = -log₂(x)
                    // Log₂(x) graph: y = -c2 = log₂(x) = cₓ
                    const c_x = Math.log2(highlightStep.x);
                    ctx.strokeStyle = 'rgba(255, 69, 0, 0.6)';  // Match red-orange theta line
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(latticeTransform.toScreenX(minO), latticeTransform.toScreenY(c_x));
                    ctx.lineTo(latticeTransform.toScreenX(maxO), latticeTransform.toScreenY(c_x));
                    ctx.stroke();

                    // Line 3: Gray - corresponds to origin line on o-r lattice
                    // O-R lattice: r = θ*o (c3 = 0)
                    // Log₂(x) graph: y = 0
                    ctx.strokeStyle = 'rgba(128, 128, 128, 0.5)';  // Match gray theta line
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(latticeTransform.toScreenX(minO), latticeTransform.toScreenY(0));
                    ctx.lineTo(latticeTransform.toScreenX(maxO), latticeTransform.toScreenY(0));
                    ctx.stroke();

                    // Reset line dash
                    ctx.setLineDash([]);
                }

                // Draw circle for highlighted step
                if (highlightStep) {
                    const o = highlightStep.o;
                    const r = highlightStep.r;
                    const logX = highlightStep.lambda_x;
                    const negLogX = -highlightStep.lambda_x;

                    // Draw connector lines: (0,-log₂(x)) → (o,-log₂(x)) → (o,r)
                    ctx.strokeStyle = 'rgba(50, 205, 50, 0.4)';  // Lower intensity green for mirror lines
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([4, 2]);

                    // Draw horizontal line from (0,-log₂(x)) to (o,-log₂(x))
                    ctx.beginPath();
                    ctx.moveTo(latticeTransform.toScreenX(0), latticeTransform.toScreenY(negLogX));
                    ctx.lineTo(latticeTransform.toScreenX(o), latticeTransform.toScreenY(negLogX));
                    ctx.stroke();

                    // Draw vertical line from (o,-log₂(x)) to (o,r)
                    ctx.beginPath();
                    ctx.moveTo(latticeTransform.toScreenX(o), latticeTransform.toScreenY(negLogX));
                    ctx.lineTo(latticeTransform.toScreenX(o), latticeTransform.toScreenY(r));
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw circle at highlighted point's mirrored lambda_x position (-log₂(x))
                    const xMirror = latticeTransform.toScreenX(o);
                    const yMirror = latticeTransform.toScreenY(negLogX);
                    const radiusMirror = 4;  // Fixed size for mirror

                    ctx.fillStyle = 'rgba(50, 205, 50, 0.3)';  // Lower intensity for mirror
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';  // Lower intensity stroke
                    ctx.lineWidth = 1;

                    ctx.beginPath();
                    ctx.arc(xMirror, yMirror, radiusMirror, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();

                    // Draw circle at highlighted point's lambda_x position
                    const x = latticeTransform.toScreenX(o);
                    const y = latticeTransform.toScreenY(logX);
                    const radius = highlightStep.beta + 3;

                    ctx.fillStyle = 'rgba(50, 205, 50, 0.5)';  // Semi-transparent green (lime green)
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';  // Semi-transparent black stroke
                    ctx.lineWidth = 1;

                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }

                // Draw circles only for visible steps (respects "show evens" toggle)
                for (const seq of sequences) {
                    const visibleSteps = latticeTransform.getVisibleSteps(seq);
                    for (const step of visibleSteps) {
                        const o = step.o;
                        const logX = step.lambda_x;

                        // Draw circle at x point
                        const x = latticeTransform.toScreenX(o);
                        const y = latticeTransform.toScreenY(logX);
                        const radius = step.beta + 3;

                        // Check if this step is the descent term - color it cyan
                        const isDescentTerm = latticeTransform.descentTerm && step.n === latticeTransform.descentTerm.n;
                        ctx.fillStyle = isDescentTerm ? 'rgba(0, 255, 255, 0.7)' : 'rgba(50, 205, 50, 0.5)';  // Cyan for descent, green for others
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';  // Semi-transparent black stroke
                        ctx.lineWidth = 1;

                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                    }
                }

                // Draw mirrored circles at -log₂(x) with fixed size and lower intensity
                for (const seq of sequences) {
                    const visibleSteps = latticeTransform.getVisibleSteps(seq);
                    for (const step of visibleSteps) {
                        const o = step.o;
                        const negLogX = -step.lambda_x;

                        // Draw mirrored circle
                        const x = latticeTransform.toScreenX(o);
                        const y = latticeTransform.toScreenY(negLogX);
                        const radius = 4;  // Fixed size

                        // Check if this step is the descent term - color it cyan
                        const isDescentTerm = latticeTransform.descentTerm && step.n === latticeTransform.descentTerm.n;
                        ctx.fillStyle = isDescentTerm ? 'rgba(0, 255, 255, 0.3)' : 'rgba(50, 205, 50, 0.2)';  // Cyan for descent, green for others
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';  // Lower intensity stroke
                        ctx.lineWidth = 1;

                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                    }
                }
            }
        }

        // Epsilon layer - plots ε = (cₒ,ᵣ - cₓ)/√(1+θ²) on right axis
        class EpsilonLayer extends Layer {
            constructor(enabled = false) {
                super('Epsilon', enabled);
                this.usesRightAxis = true;
                this.rightAxisLabel = 'ε = (cₒ,ᵣ - cₓ)/√(1+θ²)';
            }

            getRightAxisBounds(sequences) {
                const theta = 2 - Math.log2(3);
                const normFactor = Math.sqrt(1 + theta * theta);

                let minEpsilon = Infinity;
                let maxEpsilon = -Infinity;

                for (const seq of sequences) {
                    for (const step of seq.steps) {
                        if (step.x % 2 === 1) {
                            const c_or = theta * step.o - step.r;
                            const c_x = Math.log2(step.x);
                            const epsilon = (c_or - c_x) / normFactor;

                            minEpsilon = Math.min(minEpsilon, epsilon);
                            maxEpsilon = Math.max(maxEpsilon, epsilon);
                        }
                    }
                }

                return { min: minEpsilon, max: maxEpsilon };
            }

            render(ctx, sequences, latticeTransform, rightAxisTransform) {
                if (!rightAxisTransform) return;

                const theta = 2 - Math.log2(3);
                const normFactor = Math.sqrt(1 + theta * theta);

                for (const seq of sequences) {
                    for (const step of seq.steps) {
                        // Check if this step is the descent term
                        const isDescentTerm = latticeTransform.descentTerm && step.n === latticeTransform.descentTerm.n;

                        // Show odd x values OR descent term (even if even)
                        if (step.x % 2 === 1 || isDescentTerm) {
                            const c_or = theta * step.o - step.r;
                            const c_x = Math.log2(step.x);
                            const epsilon = (c_or - c_x) / normFactor;

                            const x = latticeTransform.toScreenX(step.o);
                            const y = rightAxisTransform.toScreenY(epsilon);
                            const radius = 4; // Fixed size for epsilon points

                            ctx.fillStyle = isDescentTerm ? 'rgba(0, 255, 255, 0.7)' : 'rgba(255, 0, 255, 0.5)';  // Cyan for descent, magenta for others
                            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                            ctx.lineWidth = 1;

                            ctx.beginPath();
                            ctx.arc(x, y, radius, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.stroke();
                        }
                    }
                }
            }
        }

        // Canvas renderer for the O-R lattice
        class LatticeRenderer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.sequences = [];
                this.transform = {
                    offsetX: 0,
                    offsetY: 0,
                    scale: 1
                };
                this.hoveredPoint = null;
                this.descentTerm = null;  // Descent term for hovered point
                this.showEvenTerms = false; // Default to false - only show odd terms

                // Layer management
                this.layers = [];
                this.rightAxisLayers = [];
                this.rightAxisScale = null;

                // Animation state
                this.animationT = 0; // 0 = normal (o,r), 1 = transformed (o,-log₂(x))
                this.isAnimating = false;
                this.animationDirection = 1; // 1 = forward, -1 = backward

                // Tooltip positioning
                // null = auto (smart placement based on quadrant)
                // or one of: 'top-left', 'top-right', 'bottom-left', 'bottom-right'
                this.tooltipPosition = null;

                // Selection state for drag-to-select (horizontal bands)
                this.isSelecting = false;
                this.selectionStart = null;  // {x, y} screen coordinates
                this.selectionEnd = null;    // {x, y} screen coordinates
                this.selectionRect = null;   // {x, y, width, height}
                this.onSelectionComplete = null;  // Callback when selection completes

                // Anchor k value for highlighting (derived range computed on render)
                this.anchor_k = null;

                this.initializeLayers();
                this.setupEventListeners();
            }

            initializeLayers() {
                // Add layers in rendering order
                this.addLayer(new GridLayer());
                this.addLayer(new AxesLayer());
                this.addLayer(new OEBlocksLayer());
                this.addLayer(new PathLayer());
                this.addLayer(new XValueLayer());

                // Right-axis layers
                this.addRightAxisLayer(new EpsilonLayer());
            }

            addLayer(layer) {
                this.layers.push(layer);
            }

            addRightAxisLayer(layer) {
                this.rightAxisLayers.push(layer);
            }

            findLayer(name) {
                // Search in both arrays
                let layer = this.layers.find(l => l.name === name);
                if (!layer) {
                    layer = this.rightAxisLayers.find(l => l.name === name);
                }
                return layer;
            }

            setupEventListeners() {
                // Mousedown - start selection
                this.canvas.addEventListener('mousedown', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    this.isSelecting = true;
                    this.selectionStart = { x: mouseX, y: mouseY };
                    this.selectionEnd = { x: mouseX, y: mouseY };
                    this.updateSelectionRect();
                });

                // Mouseup - complete selection
                this.canvas.addEventListener('mouseup', (e) => {
                    if (this.isSelecting) {
                        this.isSelecting = false;

                        // Only process if it was a real horizontal drag (not just a click)
                        if (this.selectionRect && this.selectionRect.width > 5) {
                            this.processSelection();
                        }

                        this.selectionRect = null;
                        this.selectionStart = null;
                        this.selectionEnd = null;
                        this.render();
                    }
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    // Handle selection drag
                    if (this.isSelecting) {
                        this.selectionEnd = { x: mouseX, y: mouseY };
                        this.updateSelectionRect();
                        this.render();
                        return; // Skip hover logic while selecting
                    }

                    const newHoveredPoint = this.findPointAtPosition(mouseX, mouseY);

                    // Reset tooltip position if we moved to a different point
                    if (!this.hoveredPoint || !newHoveredPoint ||
                        this.hoveredPoint.step.n !== newHoveredPoint.step.n) {
                        this.tooltipPosition = null;
                    }

                    this.hoveredPoint = newHoveredPoint;

                    // Compute descent term for hovered point
                    if (this.hoveredPoint && this.hoveredPoint.sequence) {
                        this.descentTerm = this.hoveredPoint.sequence.findFirstDescentTerm(this.hoveredPoint.step);
                    } else {
                        this.descentTerm = null;
                    }

                    this.render();
                });

                this.canvas.addEventListener('mouseleave', () => {
                    // Cancel selection if mouse leaves canvas
                    if (this.isSelecting) {
                        this.isSelecting = false;
                        this.selectionRect = null;
                        this.selectionStart = null;
                        this.selectionEnd = null;
                    }

                    this.hoveredPoint = null;
                    this.descentTerm = null;
                    this.tooltipPosition = null;
                    this.render();
                });

                this.canvas.addEventListener('dblclick', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    const point = this.findPointAtPosition(mouseX, mouseY);
                    if (point && this.onPointDoubleClick) {
                        this.onPointDoubleClick(point.step.x);
                    }
                });

                // Keyboard controls for tooltip positioning
                document.addEventListener('keydown', (e) => {
                    if (!this.hoveredPoint) return;

                    const key = e.key.toLowerCase();
                    if (!['u', 'l', 'd', 'r'].includes(key)) return;

                    e.preventDefault();

                    // Get current position (or auto-calculated position)
                    let currentPos = this.tooltipPosition || this.getAutoTooltipPosition(this.hoveredPoint);

                    // Move tooltip based on key
                    const [vertical, horizontal] = currentPos.split('-');
                    let newVertical = vertical;
                    let newHorizontal = horizontal;

                    if (key === 'u' && vertical === 'bottom') newVertical = 'top';
                    if (key === 'd' && vertical === 'top') newVertical = 'bottom';
                    if (key === 'l' && horizontal === 'right') newHorizontal = 'left';
                    if (key === 'r' && horizontal === 'left') newHorizontal = 'right';

                    this.tooltipPosition = `${newVertical}-${newHorizontal}`;
                    this.render();
                });
            }

            getAutoTooltipPosition(hoveredPoint) {
                // Determine tooltip position based on quadrant of hovered point
                // Place tooltip on opposite side to avoid obscuring the point
                const step = hoveredPoint.step;
                const x = this.toScreenX(step.o);
                const y = this.toScreenY(step.r);

                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;

                // Determine quadrant and place tooltip on opposite side
                const isLeft = x < centerX;
                const isTop = y < centerY;

                if (isTop && isLeft) {
                    return 'bottom-right';
                } else if (isTop && !isLeft) {
                    return 'bottom-left';
                } else if (!isTop && isLeft) {
                    return 'top-right';
                } else {
                    return 'top-left';
                }
            }

            startAnimation() {
                if (this.isAnimating) return;

                this.isAnimating = true;
                // Toggle direction based on current position
                if (this.animationT >= 1) {
                    this.animationDirection = -1; // Go back to normal
                } else if (this.animationT <= 0) {
                    this.animationDirection = 1; // Go to lambda_x
                }

                this.animateStep();
            }

            animateStep() {
                if (!this.isAnimating) return;

                const duration = 1500; // 1.5 seconds
                const deltaT = (this.animationDirection * 16) / duration; // Approx 16ms per frame

                this.animationT += deltaT;

                // Clamp and stop at bounds
                if (this.animationT >= 1) {
                    this.animationT = 1;
                    this.isAnimating = false;
                } else if (this.animationT <= 0) {
                    this.animationT = 0;
                    this.isAnimating = false;
                }

                // Apply easing (smooth start and stop)
                const t = this.animationT;
                const easedT = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

                this.currentEasedT = easedT;
                this.render();

                if (this.isAnimating) {
                    requestAnimationFrame(() => this.animateStep());
                } else {
                    // Animation completed, update button text
                    if (this.onAnimationComplete) {
                        this.onAnimationComplete();
                    }
                }
            }

            getAnimatedY(step) {
                // Interpolate between r and log₂(x)
                const t = this.currentEasedT || 0;
                return (1 - t) * step.r + t * step.lambda_x;
            }

            findPointAtPosition(mouseX, mouseY) {
                const hoverRadius = 10; // pixels

                for (const seq of this.sequences) {
                    const visibleSteps = this.getVisibleSteps(seq);

                    for (const step of visibleSteps) {
                        const x = this.toScreenX(step.o);
                        const y = this.toScreenY(step.r);
                        const dx = mouseX - x;
                        const dy = mouseY - y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance <= hoverRadius) {
                            // Return both step and sequence
                            return { step, sequence: seq };
                        }
                    }
                }
                return null;
            }

            // Selection helper methods
            updateSelectionRect() {
                if (!this.selectionStart || !this.selectionEnd) {
                    this.selectionRect = null;
                    return;
                }

                const x = Math.min(this.selectionStart.x, this.selectionEnd.x);
                const y = Math.min(this.selectionStart.y, this.selectionEnd.y);
                const width = Math.abs(this.selectionEnd.x - this.selectionStart.x);
                const height = Math.abs(this.selectionEnd.y - this.selectionStart.y);

                this.selectionRect = { x, y, width, height };
            }

            findPointsInSelection() {
                if (!this.selectionRect) return [];

                const { x, width } = this.selectionRect;
                const points = [];

                for (const seq of this.sequences) {
                    const visibleSteps = this.getVisibleSteps(seq);

                    for (const step of visibleSteps) {
                        const screenX = this.toScreenX(step.o);

                        // Check if point is within horizontal selection range
                        if (screenX >= x && screenX <= x + width) {
                            points.push({ step, sequence: seq });
                        }
                    }
                }

                return points;
            }

            processSelection() {
                const selectedPoints = this.findPointsInSelection();

                if (selectedPoints.length === 0) return;
                if (this.sequences.length === 0) return;

                const sequence = this.sequences[0];

                // Find rightmost point (highest o value) - defines the block start
                const rightmostPoint = selectedPoints.reduce((max, p) =>
                    p.step.o > max.step.o ? p : max
                );

                // Find leftmost point (lowest o value) - used to find first complete block
                const leftmostPoint = selectedPoints.reduce((min, p) =>
                    p.step.o < min.step.o ? p : min
                );

                // The rightmost odd term becomes x₀
                // Find the rightmost odd at or before the rightmost selected point
                let newX = null;
                let rightmostOddN = null;
                for (let i = rightmostPoint.step.n; i >= 0; i--) {
                    const step = sequence.steps[i];
                    if (step.x % 2 === 1) {
                        newX = step.x;
                        rightmostOddN = i;
                        break;
                    }
                }

                if (newX === null) return;

                // Find the first complete block contained within the selection
                // A complete block means the full (OE)+E+ pattern including all trailing E's
                const blocks = sequence.findOEBlocks();
                let anchorBoundaryN = null;

                for (const block of blocks) {
                    // Block indices in step space (OE string index + 1)
                    const blockStartStepN = block.start + 1;
                    const blockEndStepN = block.end + 1;  // Last E in E+ portion

                    // Check if the FULL block (including E+) is contained within selection
                    // Block must start at or after leftmost and end at or before rightmost
                    if (blockStartStepN >= leftmostPoint.step.n &&
                        blockEndStepN <= rightmostPoint.step.n) {
                        // Use the end of the E+ portion as our anchor boundary
                        anchorBoundaryN = blockEndStepN;
                        break; // First complete block found
                    }
                }

                // If no complete block found, use the leftmost odd in selection
                if (anchorBoundaryN === null) {
                    const oddPoints = selectedPoints.filter(p => p.step.x % 2 === 1);
                    if (oddPoints.length === 0) return;

                    const leftmostOdd = oddPoints.reduce((min, p) =>
                        p.step.o < min.step.o ? p : min
                    );
                    anchorBoundaryN = leftmostOdd.step.n;
                }

                // Count even steps between anchor boundary and rightmost odd
                // anchorBoundaryN is to the LEFT (lower o), rightmostOddN is to the RIGHT (higher o)
                let anchor_k = 0;
                const startN = Math.min(anchorBoundaryN, rightmostOddN);
                const endN = Math.max(anchorBoundaryN, rightmostOddN);
                for (let i = startN + 1; i < endN; i++) {
                    const step = sequence.steps[i];
                    if (step && step.x % 2 === 0) {
                        anchor_k++;
                    }
                }

                // Trigger callback to application
                if (this.onSelectionComplete) {
                    this.onSelectionComplete(newX, anchor_k);
                }
            }

            drawSelectionRect() {
                if (!this.selectionRect) return;

                const { x, width } = this.selectionRect;

                // Draw horizontal band (full canvas height)
                this.ctx.fillStyle = 'rgba(74, 158, 255, 0.2)';
                this.ctx.fillRect(x, 0, width, this.canvas.height);

                // Draw vertical lines at edges
                this.ctx.strokeStyle = 'rgba(74, 158, 255, 0.8)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 3]);
                this.ctx.beginPath();
                this.ctx.moveTo(x, 0);
                this.ctx.lineTo(x, this.canvas.height);
                this.ctx.moveTo(x + width, 0);
                this.ctx.lineTo(x + width, this.canvas.height);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }

            computeAnchorRange() {
                // Derive anchor range from anchor_k and current sequence
                if (this.anchor_k === null || this.anchor_k < 0) return null;
                if (this.sequences.length === 0) return null;

                const sequence = this.sequences[0];
                const steps = sequence.steps;
                if (steps.length === 0) return null;

                // Start at step 0, count evens, find the last odd within anchor_k evens
                let evenCount = 0;
                let lastOddO = steps[0].o;

                for (let i = 1; i < steps.length; i++) {
                    const step = steps[i];
                    if (step.x % 2 === 0) {
                        evenCount++;
                        if (evenCount > this.anchor_k) {
                            break; // Exceeded anchor_k evens
                        }
                    } else {
                        lastOddO = step.o; // Update last odd within range
                    }
                }

                return { minO: steps[0].o, maxO: lastOddO };
            }

            drawAnchorRange() {
                const anchorRange = this.computeAnchorRange();
                if (!anchorRange) return;

                const { minO, maxO } = anchorRange;
                // Offset boundaries outward by 1/3 of a grid square on each side
                // Left boundary at o_left - 1/3, right boundary at o_right + 1/3
                const offset = this.transform.scale / 3;
                const leftX = this.toScreenX(minO) + offset;
                const rightX = this.toScreenX(maxO) - offset;
                const width = rightX - leftX;

                // Draw semi-transparent highlight band
                this.ctx.fillStyle = 'rgba(74, 158, 255, 0.15)';
                this.ctx.fillRect(leftX, 0, width, this.canvas.height);

                // Draw solid vertical lines at edges
                this.ctx.strokeStyle = 'rgba(74, 158, 255, 0.5)';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([]);
                this.ctx.beginPath();
                this.ctx.moveTo(leftX, 0);
                this.ctx.lineTo(leftX, this.canvas.height);
                this.ctx.moveTo(rightX, 0);
                this.ctx.lineTo(rightX, this.canvas.height);
                this.ctx.stroke();
            }

            getVisibleSteps(sequence) {
                // Returns steps that should be visible based on showEvenTerms setting
                if (this.showEvenTerms) {
                    return sequence.steps;
                } else {
                    // Show odd x, start, last even in each (OE)+ sequence, and descent term (always visible)
                    const lastEvenIndices = new Set(sequence.getLastEvenInOEPlusIndices());
                    return sequence.steps.filter((s, idx) =>
                        s.x % 2 === 1 ||
                        s.type === 'start' ||
                        lastEvenIndices.has(idx) ||
                        (this.descentTerm && s.n === this.descentTerm.n)  // Always show descent term
                    );
                }
            }

            clear() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.sequences = [];
            }

            addSequence(sequence) {
                this.sequences.push(sequence);
                this.fitToView();
                this.render();
            }

            fitToView() {
                if (this.sequences.length === 0) return;

                // Get combined bounds from visible steps
                let minO = Infinity, maxO = -Infinity;
                let minR = Infinity, maxR = -Infinity;

                for (const seq of this.sequences) {
                    const visibleSteps = this.getVisibleSteps(seq);

                    for (const step of visibleSteps) {
                        minO = Math.min(minO, step.o);
                        maxO = Math.max(maxO, step.o);
                        minR = Math.min(minR, step.r);
                        maxR = Math.max(maxR, step.r);

                        // Also consider lambda_x values for viewport bounds (both positive and negative)
                        const logX = step.lambda_x;
                        minR = Math.min(minR, logX, -logX);
                        maxR = Math.max(maxR, logX, -logX);
                    }
                }

                // Add padding
                const padding = 2;
                minO -= padding;
                maxO += padding;
                minR -= padding;
                maxR += padding;

                // Calculate scale to fit
                const rangeO = maxO - minO;
                const rangeR = maxR - minR;
                const scaleO = (this.canvas.width - 100) / rangeO;
                const scaleR = (this.canvas.height - 100) / rangeR;
                this.transform.scale = Math.min(scaleO, scaleR, CONFIG.gridSize);

                // Center the view
                this.transform.offsetX = 50 - minO * this.transform.scale;
                this.transform.offsetY = this.canvas.height - 50 + minR * this.transform.scale;
            }

            toScreenX(o) {
                return this.transform.offsetX + o * this.transform.scale;
            }

            toScreenY(r) {
                return this.transform.offsetY - r * this.transform.scale;
            }

            calculateRightAxisScale() {
                // Calculate bounds for all enabled right-axis layers
                let minValue = Infinity;
                let maxValue = -Infinity;
                let hasEnabledLayers = false;

                for (const layer of this.rightAxisLayers) {
                    if (layer.enabled) {
                        const bounds = layer.getRightAxisBounds(this.sequences);
                        if (bounds) {
                            minValue = Math.min(minValue, bounds.min);
                            maxValue = Math.max(maxValue, bounds.max);
                            hasEnabledLayers = true;
                        }
                    }
                }

                if (!hasEnabledLayers) {
                    this.rightAxisScale = null;
                    return;
                }

                // Add some padding
                const range = maxValue - minValue;
                const padding = range * 0.1;
                minValue -= padding;
                maxValue += padding;

                this.rightAxisScale = {
                    min: minValue,
                    max: maxValue,
                    range: maxValue - minValue
                };
            }

            drawRightAxis() {
                if (!this.rightAxisScale) return;

                // Calculate right axis position (right edge of canvas with margin)
                const margin = 80;
                const axisX = this.canvas.width - margin;

                // Get canvas bounds in screen coordinates
                const topY = 50;
                const bottomY = this.canvas.height - 50;

                // Helper to convert value to screen Y
                const valueToScreenY = (value) => {
                    const normalized = (value - this.rightAxisScale.min) / this.rightAxisScale.range;
                    return bottomY - normalized * (bottomY - topY);
                };

                // Draw axis line
                this.ctx.strokeStyle = CONFIG.colors.axes;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(axisX, topY);
                this.ctx.lineTo(axisX, bottomY);
                this.ctx.stroke();

                // Draw tick marks and labels
                this.ctx.fillStyle = '#e0e0e0';  // Brighter tick text
                this.ctx.font = '12px sans-serif';
                this.ctx.textAlign = 'left';
                this.ctx.textBaseline = 'middle';

                // Calculate nice tick intervals
                const numTicks = 5;
                const tickStep = this.rightAxisScale.range / numTicks;

                for (let i = 0; i <= numTicks; i++) {
                    const value = this.rightAxisScale.min + i * tickStep;
                    const y = valueToScreenY(value);

                    // Tick mark
                    this.ctx.strokeStyle = CONFIG.colors.axes;
                    this.ctx.beginPath();
                    this.ctx.moveTo(axisX - 5, y);
                    this.ctx.lineTo(axisX + 5, y);
                    this.ctx.stroke();

                    // Label
                    this.ctx.fillText(value.toFixed(1), axisX + 10, y);
                }

                // Draw λₘ = 0 line if 0 is within range
                if (this.rightAxisScale.min <= 0 && this.rightAxisScale.max >= 0) {
                    const zeroY = valueToScreenY(0);
                    this.ctx.strokeStyle = '#888';
                    this.ctx.lineWidth = 1;
                    this.ctx.setLineDash([5, 3]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(50, zeroY);
                    this.ctx.lineTo(this.canvas.width - margin, zeroY);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }

                // Draw axis labels for enabled layers
                const enabledLabels = this.rightAxisLayers
                    .filter(l => l.enabled && l.rightAxisLabel)
                    .map(l => l.rightAxisLabel);

                if (enabledLabels.length > 0) {
                    this.ctx.save();
                    this.ctx.translate(this.canvas.width - 20, (topY + bottomY) / 2);
                    this.ctx.rotate(-Math.PI / 2);
                    this.ctx.textAlign = 'center';
                    this.ctx.fillStyle = '#e0e0e0';  // Brighter axis label
                    this.ctx.fillText(enabledLabels.join(', '), 0, 0);
                    this.ctx.restore();
                }
            }

            render() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Calculate right axis bounds from enabled layers
                this.calculateRightAxisScale();

                // Create lattice transform object for layers
                const latticeTransform = {
                    toScreenX: this.toScreenX.bind(this),
                    toScreenY: this.toScreenY.bind(this),
                    getVisibleSteps: this.getVisibleSteps.bind(this),
                    hoveredPoint: this.hoveredPoint,
                    descentTerm: this.descentTerm,  // Pass descent term to layers
                    defaultStep: this.sequences.length > 0 ? this.sequences[0].steps[0] : null,
                    getAnimatedY: this.getAnimatedY.bind(this),
                    animationT: this.currentEasedT || 0
                };

                // Create right axis transform if needed
                let rightAxisTransform = null;
                if (this.rightAxisScale) {
                    const margin = 80;
                    const axisX = this.canvas.width - margin;
                    const topY = 50;
                    const bottomY = this.canvas.height - 50;

                    rightAxisTransform = {
                        toScreenX: this.toScreenX.bind(this),
                        toScreenY: (value) => {
                            const normalized = (value - this.rightAxisScale.min) / this.rightAxisScale.range;
                            return bottomY - normalized * (bottomY - topY);
                        }
                    };
                }

                // Render regular layers
                for (const layer of this.layers) {
                    if (layer.enabled) {
                        layer.render(this.ctx, this.sequences, latticeTransform);
                    }
                }

                // Draw right axis
                this.drawRightAxis();

                // Render right-axis layers
                for (const layer of this.rightAxisLayers) {
                    if (layer.enabled) {
                        layer.render(this.ctx, this.sequences, latticeTransform, rightAxisTransform);
                    }
                }

                // Draw theta reference lines
                this.drawThetaLines();

                // Draw lambda_x reference line
                this.drawLambdaXLine(rightAxisTransform);

                // Draw anchor range highlight (persistent selection)
                this.drawAnchorRange();

                // Draw selection rectangle if selecting
                if (this.isSelecting && this.selectionRect) {
                    this.drawSelectionRect();
                }

                // Draw tooltip last (on top)
                if (this.hoveredPoint) {
                    this.drawTooltip(this.hoveredPoint);
                }
            }

            drawThetaLines() {
                if (this.sequences.length === 0) return;

                // Calculate theta = 2 - log_2(3)
                const theta = 2 - Math.log2(3);

                // Determine which point to use for reference
                let refStep;
                if (this.hoveredPoint) {
                    refStep = this.hoveredPoint.step;
                } else {
                    // Use the first step (x0) of the first sequence
                    refStep = this.sequences[0].steps[0];
                }

                // Get bounds for drawing lines across the canvas
                let minO = Infinity, maxO = -Infinity;
                for (const seq of this.sequences) {
                    const visibleSteps = this.getVisibleSteps(seq);
                    for (const step of visibleSteps) {
                        minO = Math.min(minO, step.o);
                        maxO = Math.max(maxO, step.o);
                    }
                }
                minO = Math.floor(minO) - 2;
                maxO = Math.ceil(maxO) + 2;

                // Line 1: x-estimator - passes through (o_ref, r_ref)
                // Given (o,r), estimates x from r-axis intercept
                const c1 = refStep.r - theta * refStep.o;
                const r1_start = theta * minO + c1;
                const r1_end = theta * maxO + c1;

                this.ctx.strokeStyle = 'rgba(255, 140, 0, 0.6)';  // Semi-transparent orange
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([6, 3]);
                this.ctx.beginPath();
                this.ctx.moveTo(this.toScreenX(minO), this.toScreenY(r1_start));
                this.ctx.lineTo(this.toScreenX(maxO), this.toScreenY(r1_end));
                this.ctx.stroke();

                // Line 2: (o,r)-estimator - passes through (0, -log_2(x_ref))
                // Given x, estimates where (o,r) should fall
                const c2 = -Math.log2(refStep.x);
                const r2_start = theta * minO + c2;
                const r2_end = theta * maxO + c2;

                this.ctx.strokeStyle = 'rgba(255, 69, 0, 0.6)';  // Semi-transparent red-orange
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([3, 3]);
                this.ctx.beginPath();
                this.ctx.moveTo(this.toScreenX(minO), this.toScreenY(r2_start));
                this.ctx.lineTo(this.toScreenX(maxO), this.toScreenY(r2_end));
                this.ctx.stroke();

                // Line 3: Passes through origin (0, 0)
                // r = theta * o (intercept = 0)
                const r3_start = theta * minO;
                const r3_end = theta * maxO;

                this.ctx.strokeStyle = 'rgba(128, 128, 128, 0.5)';  // Semi-transparent gray
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([2, 2]);
                this.ctx.beginPath();
                this.ctx.moveTo(this.toScreenX(minO), this.toScreenY(r3_start));
                this.ctx.lineTo(this.toScreenX(maxO), this.toScreenY(r3_end));
                this.ctx.stroke();

                // Reset line dash
                this.ctx.setLineDash([]);
            }

            drawLambdaXLine(rightAxisTransform) {
                if (!rightAxisTransform || this.sequences.length === 0) return;

                // Find the XValueLayer to check orientation setting
                const xValueLayer = this.rightAxisLayers.find(l => l instanceof XValueLayer);
                if (!xValueLayer) return;

                const flipOrientation = xValueLayer.flipOrientation;
                let value;

                // Use hovered point if available, otherwise use initial x0
                if (this.hoveredPoint) {
                    value = flipOrientation ? -this.hoveredPoint.step.lambda_x : this.hoveredPoint.step.lambda_x;
                } else {
                    // Use the first step (x0) of the first sequence
                    value = flipOrientation ? -this.sequences[0].steps[0].lambda_x : this.sequences[0].steps[0].lambda_x;
                }

                const y = rightAxisTransform.toScreenY(value);
                const margin = 80;

                // Draw horizontal line across canvas at lambda_x (or -lambda_x)
                this.ctx.strokeStyle = 'rgba(68, 200, 255, 0.7)';  // Cyan to match X layer
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([8, 4]);
                this.ctx.beginPath();
                this.ctx.moveTo(50, y);
                this.ctx.lineTo(this.canvas.width - margin, y);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }

            drawTooltip(hoveredPoint) {
                const step = hoveredPoint.step;
                const sequence = hoveredPoint.sequence;

                const x = this.toScreenX(step.o);
                const y = this.toScreenY(step.r);

                // Highlight the hovered point
                this.ctx.fillStyle = '#ffff00';
                this.ctx.beginPath();
                this.ctx.arc(x, y, CONFIG.pointRadius + 2, 0, 2 * Math.PI);
                this.ctx.fill();

                // Find which block this step belongs to
                const stepIndex = step.n;
                const blockPattern = sequence.getBlockForStep(stepIndex);

                // Build tooltip text lines in order: o, r, e, x, j, i, m, k
                const lines = [];

                // Optional block pattern at top
                if (blockPattern) {
                    lines.push(blockPattern);
                }

                // Lattice position
                lines.push(`o = ${step.o}`);
                lines.push(`r = ${step.r}`);
                lines.push(`e = ${step.e}`);

                // Element - include 2^ν factor for even values
                if (step.x % 2 === 0) {
                    lines.push(`x = 2^ν·(2^α·(3^γ·ρ + t·2^(β+1)) - 1) = ${step.x}`);
                } else {
                    lines.push(`x = 2^α·(3^γ·ρ + t·2^(β+1)) - 1 = ${step.x}`);
                }

                // First descent term (right after x)
                if (this.descentTerm) {
                    lines.push(`x₍fd₎ = ${this.descentTerm.x}`);
                } else {
                    lines.push(`x₍fd₎ = none`);
                }

                lines.push(`λₓ = log₂(x) = ${step.lambda_x.toFixed(3)}`);

                // Derived parameters (in derivation order)
                lines.push(`ν = v₂(x) = ${step.nu}`);
                lines.push(`α = v₂(x+1) = ${step.alpha}`);
                lines.push(`m = (x+1)/2^α = ${step.m}`);
                lines.push(`β = v₂(3^α·m - 1) = ${step.beta}`);
                lines.push(`γ = v₃(m mod 2^(β+1)) = ${step.gamma}`);
                lines.push(`ρ = (m mod 2^(β+1))/3^γ = ${step.rho}`);
                lines.push(`t = ⌊m/2^(β+1)⌋ = ${step.t}`);
                lines.push(`d = 2^(2o-r) - 3^o = ${step.d}`);
                lines.push(`k = 2^e - 3^o·x = ${step.k}`);
                lines.push(`λₖ = log₂(k) = ${step.lambda_k.toFixed(3)}`);

                // Theta-line intercepts and distances
                const theta = 2 - Math.log2(3);
                const c_or = theta * step.o - step.r;
                const c_x = Math.log2(step.x);
                const normFactor = Math.sqrt(1 + theta * theta);
                const L = c_or / normFactor;
                const epsilon = (c_or - c_x) / normFactor;

                lines.push(`θ = 2 - log₂(3) = ${theta.toFixed(4)}`);
                lines.push(`cₒ,ᵣ = θ·o - r = ${c_or.toFixed(3)}`);
                lines.push(`cₓ = log₂(x) = ${c_x.toFixed(3)}`);
                lines.push(`L = cₒ,ᵣ/√(1+θ²) = ${L.toFixed(3)}`);
                lines.push(`ε = (cₒ,ᵣ-cₓ)/√(1+θ²) = ${epsilon.toFixed(3)}`)

                this.ctx.font = '14px monospace';
                const padding = 10;
                const lineHeight = 18;

                // Calculate box dimensions
                let boxWidth = 0;
                for (const line of lines) {
                    const metrics = this.ctx.measureText(line);
                    boxWidth = Math.max(boxWidth, metrics.width);
                }
                boxWidth += padding * 2;
                const boxHeight = lines.length * lineHeight + padding * 2;

                // Determine tooltip position: use manual override or auto-calculate based on quadrant
                const position = this.tooltipPosition || this.getAutoTooltipPosition(hoveredPoint);
                const [vertical, horizontal] = position.split('-');

                const margin = 10;
                let tooltipX, tooltipY;

                // Position based on vertical/horizontal components
                if (horizontal === 'left') {
                    tooltipX = margin;
                } else {
                    tooltipX = this.canvas.width - boxWidth - margin;
                }

                if (vertical === 'top') {
                    tooltipY = margin;
                } else {
                    tooltipY = this.canvas.height - boxHeight - margin;
                }

                // Draw box background
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                this.ctx.fillRect(tooltipX, tooltipY, boxWidth, boxHeight);

                // Draw box border
                this.ctx.strokeStyle = '#ffff00';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(tooltipX, tooltipY, boxWidth, boxHeight);

                // Draw text lines
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = '14px monospace';
                this.ctx.textAlign = 'left';
                this.ctx.textBaseline = 'top';

                let currentY = tooltipY + padding;
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];

                    // Center the block pattern if it exists (first line)
                    if (i === 0 && blockPattern) {
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(line, tooltipX + boxWidth / 2, currentY);
                        this.ctx.textAlign = 'left';
                    } else if (line.includes('x₍fd₎')) {
                        // Special handling for x with subscript fd
                        // Parse: "x₍fd₎ = value" -> draw x normally, fd as subscript, then " = value"
                        const parts = line.split('x₍fd₎');
                        let x = tooltipX + padding;

                        // Draw prefix (usually empty)
                        if (parts[0]) {
                            this.ctx.fillText(parts[0], x, currentY);
                            x += this.ctx.measureText(parts[0]).width;
                        }

                        // Draw 'x' in normal font
                        this.ctx.font = '14px monospace';
                        this.ctx.fillText('x', x, currentY);
                        x += this.ctx.measureText('x').width;

                        // Draw 'fd' as subscript (smaller font, offset down)
                        this.ctx.font = '10px monospace';
                        this.ctx.fillText('fd', x, currentY + 6);  // Offset down by 6px
                        x += this.ctx.measureText('fd').width;

                        // Draw rest of line (e.g., " = 40")
                        this.ctx.font = '14px monospace';
                        if (parts[1]) {
                            this.ctx.fillText(parts[1], x, currentY);
                        }
                    } else {
                        this.ctx.fillText(line, tooltipX + padding, currentY);
                    }

                    currentY += lineHeight;
                }
            }
        }

        // Heatmap renderer for (β, α) distribution
        class HeatmapRenderer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.distribution = null;
            }

            clear() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.distribution = null;
            }

            render(sequence) {
                this.distribution = sequence.getAlphaBetaDistribution();
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                if (this.distribution.length === 0) return;

                // Find bounds
                const betaValues = this.distribution.map(d => d.beta);
                const alphaValues = this.distribution.map(d => d.alpha);
                const counts = this.distribution.map(d => d.count);
                const minBeta = Math.min(...betaValues);
                const maxBeta = Math.max(...betaValues);
                const minAlpha = Math.min(...alphaValues);
                const maxAlpha = Math.max(...alphaValues);
                const maxCount = Math.max(...counts);

                // Add padding
                const padding = 60;
                const plotWidth = this.canvas.width - padding * 2;
                const plotHeight = this.canvas.height - padding * 2;

                // Calculate scale - α on x-axis, β on y-axis
                const alphaRange = maxAlpha - minAlpha || 1;
                const betaRange = maxBeta - minBeta || 1;
                const scaleX = plotWidth / alphaRange;
                const scaleY = plotHeight / betaRange;

                // Helper function to convert α,β to screen coordinates
                const toScreenX = (alpha) => padding + (alpha - minAlpha) * scaleX;
                const toScreenY = (beta) => this.canvas.height - padding - (beta - minBeta) * scaleY;

                // Draw axes
                this.ctx.strokeStyle = '#666';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(padding, this.canvas.height - padding);
                this.ctx.lineTo(this.canvas.width - padding, this.canvas.height - padding);
                this.ctx.moveTo(padding, this.canvas.height - padding);
                this.ctx.lineTo(padding, padding);
                this.ctx.stroke();

                // Draw axis labels
                this.ctx.fillStyle = '#e0e0e0';
                this.ctx.font = '16px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('α = v₂(x+1)', this.canvas.width / 2, this.canvas.height - 10);
                this.ctx.save();
                this.ctx.translate(15, this.canvas.height / 2);
                this.ctx.rotate(-Math.PI / 2);
                this.ctx.fillText('β = v₂(x)', 0, 0);
                this.ctx.restore();

                // Draw grid lines and labels
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 0.5;
                this.ctx.font = '12px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillStyle = '#999';

                // α axis ticks (x-axis)
                for (let alpha = minAlpha; alpha <= maxAlpha; alpha++) {
                    const x = toScreenX(alpha);
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, padding);
                    this.ctx.lineTo(x, this.canvas.height - padding);
                    this.ctx.stroke();
                    this.ctx.fillText(alpha.toString(), x, this.canvas.height - padding + 20);
                }

                // β axis ticks (y-axis)
                this.ctx.textAlign = 'right';
                for (let beta = minBeta; beta <= maxBeta; beta++) {
                    const y = toScreenY(beta);
                    this.ctx.beginPath();
                    this.ctx.moveTo(padding, y);
                    this.ctx.lineTo(this.canvas.width - padding, y);
                    this.ctx.stroke();
                    this.ctx.fillText(beta.toString(), padding - 10, y + 4);
                }

                // Draw bubbles
                for (const point of this.distribution) {
                    const x = toScreenX(point.alpha);
                    const y = toScreenY(point.beta);

                    // Size proportional to count (like matplotlib s=count*20)
                    const baseRadius = Math.sqrt(point.count * 20);
                    const radius = Math.min(baseRadius, 50); // Cap maximum size

                    // Color based on count (viridis-like colormap)
                    const normalized = point.count / maxCount;
                    const color = this.viridisColor(normalized);

                    // Draw circle
                    this.ctx.fillStyle = color;
                    this.ctx.globalAlpha = 0.7;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius, 0, 2 * Math.PI);
                    this.ctx.fill();

                    // Draw border
                    this.ctx.strokeStyle = '#000';
                    this.ctx.lineWidth = 1;
                    this.ctx.globalAlpha = 1.0;
                    this.ctx.stroke();

                    // Draw count label for larger bubbles
                    if (radius > 10) {
                        this.ctx.fillStyle = '#fff';
                        this.ctx.font = 'bold 12px sans-serif';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText(point.count.toString(), x, y);
                    }
                }

                this.ctx.globalAlpha = 1.0;

                // Draw title
                this.ctx.fillStyle = '#e0e0e0';
                this.ctx.font = 'bold 16px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('(α, β) Distribution', this.canvas.width / 2, 25);
            }

            // Viridis-inspired colormap
            viridisColor(t) {
                // Simplified viridis: interpolate between purple, blue, green, yellow
                t = Math.max(0, Math.min(1, t)); // Clamp to [0,1]

                if (t < 0.25) {
                    const s = t / 0.25;
                    return this.rgbToHex(68 + s * (59 - 68), 1 + s * (82 - 1), 84 + s * (139 - 84));
                } else if (t < 0.5) {
                    const s = (t - 0.25) / 0.25;
                    return this.rgbToHex(59 + s * (33 - 59), 82 + s * (145 - 82), 139 + s * (140 - 139));
                } else if (t < 0.75) {
                    const s = (t - 0.5) / 0.25;
                    return this.rgbToHex(33 + s * (94 - 33), 145 + s * (201 - 145), 140 + s * (98 - 140));
                } else {
                    const s = (t - 0.75) / 0.25;
                    return this.rgbToHex(94 + s * (253 - 94), 201 + s * (231 - 201), 98 + s * (37 - 98));
                }
            }

            rgbToHex(r, g, b) {
                r = Math.round(r);
                g = Math.round(g);
                b = Math.round(b);
                return `rgb(${r}, ${g}, ${b})`;
            }
        }

        // Main application
        class Application {
            constructor() {
                this.renderer = new LatticeRenderer('latticeCanvas');
                this.heatmapRenderer = new HeatmapRenderer('heatmapCanvas');
                this.currentSequence = null;
                this.isInitialLoad = true;
                this.anchor_k = null;  // Track congruence navigation anchor

                // Set up double-click handler
                this.renderer.onPointDoubleClick = (x) => {
                    this.loadSequenceForX(x, null);  // Clear anchor when double-clicking
                };

                // Set up animation complete handler
                this.renderer.onAnimationComplete = () => {
                    this.updateAnimateButton();
                };

                // Set up selection complete handler
                this.renderer.onSelectionComplete = (x, anchor_k) => {
                    document.getElementById('x0Input').value = x;
                    this.anchor_k = anchor_k;
                    this.plotSequence();
                    this.updateAnchorSection();
                };

                // Handle browser back/forward buttons
                window.addEventListener('popstate', (e) => {
                    // Get x and anchor_k from state or URL
                    let x, anchor_k;
                    if (e.state && e.state.x) {
                        x = e.state.x;
                        anchor_k = e.state.anchor_k;
                    } else {
                        const urlParams = new URLSearchParams(window.location.search);
                        x = parseInt(urlParams.get('x')) || 27;
                        anchor_k = parseInt(urlParams.get('anchor_k'));
                    }

                    this.anchor_k = !isNaN(anchor_k) ? anchor_k : null;
                    document.getElementById('x0Input').value = x;
                    // Don't update history when handling popstate
                    this.isInitialLoad = true;
                    this.plotSequence();
                    this.isInitialLoad = false;
                });

                // Set up congruence link navigation
                this.setupCongruenceNavigation();

                this.loadFromURL();
            }

            loadFromURL() {
                // Read x and anchor_k from query string
                const urlParams = new URLSearchParams(window.location.search);
                const xParam = urlParams.get('x');
                const anchorKParam = urlParams.get('anchor_k');

                if (xParam) {
                    const x = parseInt(xParam);
                    if (!isNaN(x) && x > 0) {
                        document.getElementById('x0Input').value = x;
                    }
                }

                if (anchorKParam) {
                    const anchor_k = parseInt(anchorKParam);
                    this.anchor_k = !isNaN(anchor_k) ? anchor_k : null;
                }
            }

            setupCongruenceNavigation() {
                // Delegate click handler for congruence links
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('congruence-link')) {
                        e.preventDefault();
                        const href = e.target.getAttribute('href');

                        // Parse both x and anchor_k from URL
                        const url = new URL(href, window.location.origin);
                        const x = parseInt(url.searchParams.get('x'));
                        const anchor_k = parseInt(url.searchParams.get('anchor_k'));

                        if (!isNaN(x)) {
                            this.loadSequenceForX(x, anchor_k);
                        }
                    }
                });
            }

            updateURL(x, anchor_k = null) {
                // Update URL without reloading the page, storing state for back button
                const url = new URL(window.location);
                url.searchParams.set('x', x);

                if (anchor_k !== null && !isNaN(anchor_k)) {
                    url.searchParams.set('anchor_k', anchor_k);
                } else {
                    url.searchParams.delete('anchor_k');
                }

                const state = { x: x };
                if (anchor_k !== null && !isNaN(anchor_k)) {
                    state.anchor_k = anchor_k;
                }

                if (this.isInitialLoad) {
                    // Replace state on initial load to avoid creating extra history entry
                    window.history.replaceState(state, '', url);
                } else {
                    // Push new state for user-initiated changes
                    window.history.pushState(state, '', url);
                }
            }

            showError(message) {
                const errorPanel = document.getElementById('errorPanel');
                errorPanel.textContent = message;
                errorPanel.style.display = 'block';
                setTimeout(() => {
                    errorPanel.style.display = 'none';
                }, 5000);
            }

            updateInfo(sequence) {
                document.getElementById('oeSequence').textContent = sequence.getOEString();
                document.getElementById('seqLength').textContent = sequence.steps.length - 1; // Exclude start

                // Display OE blocks - each with congruence navigation
                const blocks = sequence.findOEBlocks();
                const allLines = [];

                // Add maximal OE blocks
                if (blocks.length > 0) {
                    const blockLines = blocks.map((b, i) => {
                        const startStep = sequence.steps[b.start];
                        const k = sequence.getOEBlockK(b);
                        const congruences = sequence.getCongruences(startStep.x, k);

                        // Block pattern line
                        const patternLine = `x=${startStep.x}: ${b.pattern}`;

                        // Congruence navigation line
                        const congLine = formatCongruenceHTML(congruences);

                        return `${patternLine}<br>&nbsp;&nbsp;${congLine}`;
                    });
                    allLines.push(...blockLines);
                    document.getElementById('oeBlocks').innerHTML = allLines.join('<br><br>');
                } else {
                    if (allLines.length > 0) {
                        document.getElementById('oeBlocks').innerHTML = allLines.join('<br><br>');
                    } else {
                        document.getElementById('oeBlocks').textContent = 'None found';
                    }
                }

                // Update x₀ info panel
                this.updateX0Info(sequence);

                // Verify invariants
                this.verifyInvariants(sequence);
            }

            updateX0Info(sequence) {
                const step = sequence.steps[0]; // x₀
                const theta = 2 - Math.log2(3);
                const c_or = theta * step.o - step.r;
                const c_x = Math.log2(step.x);
                const normFactor = Math.sqrt(1 + theta * theta);
                const L = c_or / normFactor;
                const epsilon = (c_or - c_x) / normFactor;

                const lines = [];

                // Lattice position
                lines.push(`o = ${step.o}`);
                lines.push(`r = ${step.r}`);
                lines.push(`e = ${step.e}`);

                // Element - include 2^ν factor for even values
                if (step.x % 2 === 0) {
                    lines.push(`x = 2<sup>ν</sup>·(2<sup>α</sup>·(3<sup>γ</sup>·ρ + t·2<sup>(β+1)</sup>) - 1) = ${step.x}`);
                } else {
                    lines.push(`x = 2<sup>α</sup>·(3<sup>γ</sup>·ρ + t·2<sup>(β+1)</sup>) - 1 = ${step.x}`);
                }

                // First descent term (right after x)
                const descentTerm = sequence.findFirstDescentTerm(step);
                if (descentTerm) {
                    lines.push(`x<sub>fd</sub> = ${descentTerm.x}`);

                    // Add congruence navigation for x_fd
                    const k = sequence.getFirstDescentK(step);
                    if (k !== null) {
                        const congruences = sequence.getCongruences(step.x, k);
                        const congLine = formatCongruenceHTML(congruences);
                        lines.push(`&nbsp;&nbsp;${congLine}`);
                    }
                } else {
                    lines.push(`x<sub>fd</sub> = none`);
                }

                lines.push(`λₓ = log₂(x) = ${step.lambda_x.toFixed(3)}`);

                // Derived parameters (in derivation order)
                lines.push(`ν = v₂(x) = ${step.nu}`);
                lines.push(`α = v₂(x+1) = ${step.alpha}`);
                lines.push(`m = (x+1)/2^α = ${step.m}`);
                lines.push(`β = v₂(3^α·m - 1) = ${step.beta}`);
                lines.push(`γ = v₃(m mod 2^(β+1)) = ${step.gamma}`);
                lines.push(`ρ = (m mod 2^(β+1))/3^γ = ${step.rho}`);
                lines.push(`t = ⌊m/2^(β+1)⌋ = ${step.t}`);
                lines.push(`d = 2^(2o-r) - 3^o = ${step.d}`);
                lines.push(`k = 2^e - 3^o·x = ${step.k}`);
                lines.push(`λₖ = log₂(k) = ${step.lambda_k.toFixed(3)}`);

                // Theta-line intercepts and distances
                lines.push(`θ = 2 - log₂(3) = ${theta.toFixed(4)}`);
                lines.push(`cₒ,ᵣ = θ·o - r = ${c_or.toFixed(3)}`);
                lines.push(`cₓ = log₂(x) = ${c_x.toFixed(3)}`);
                lines.push(`L = cₒ,ᵣ/√(1+θ²) = ${L.toFixed(3)}`);
                lines.push(`ε = (cₒ,ᵣ-cₓ)/√(1+θ²) = ${epsilon.toFixed(3)}`)

                // Use innerHTML instead of textContent to render HTML tags like <sub>
                document.getElementById('infoContent').innerHTML = lines.join('<br>');
                document.getElementById('infoPanel').style.display = 'block';
            }

            verifyInvariants(sequence) {
                const distribution = sequence.getAlphaBetaDistribution();
                const finalStep = sequence.steps[0]; // Initial step has the final o, r values

                // Invariant 1: sum(count for cells where α=1) should equal o
                let sumAlpha1 = 0;
                for (const point of distribution) {
                    if (point.alpha === 1) {
                        sumAlpha1 += point.count;
                    }
                }

                // Invariant 2: sum(count * (α-2) for cells where β=1) should equal r
                let sumBeta1 = 0;
                for (const point of distribution) {
                    if (point.beta === 1) {
                        sumBeta1 += point.count * (point.alpha - 2);
                    }
                }

                console.log('=== Invariant Check ===');
                console.log(`x0 = ${sequence.x0}`);
                console.log(`Final o = ${finalStep.o}, r = ${finalStep.r}`);
                console.log(`Invariant 1: sum(count for α=1) = ${sumAlpha1}, expected o = ${finalStep.o}, ✓=${sumAlpha1 === finalStep.o}`);
                console.log(`Invariant 2: sum(count * (α-2) for β=1) = ${sumBeta1}, expected r = ${finalStep.r}, ✓=${sumBeta1 === finalStep.r}`);
                console.log('Distribution:', distribution);
            }

            plotSequence() {
                try {
                    const x0 = parseInt(document.getElementById('x0Input').value);
                    if (isNaN(x0) || x0 < 1) {
                        this.showError('Please enter a valid positive integer');
                        return;
                    }

                    // Pass anchor_k to renderer for highlighting
                    this.renderer.anchor_k = this.anchor_k;

                    const sequence = new CollatzSequence(x0);
                    this.currentSequence = sequence;
                    this.renderer.clear();
                    this.renderer.addSequence(sequence);
                    this.heatmapRenderer.render(sequence);
                    this.updateInfo(sequence);

                    // Update URL to reflect current x value and anchor_k
                    this.updateURL(x0, this.anchor_k);

                    // Update anchor section display
                    this.updateAnchorSection();

                } catch (error) {
                    this.showError(error.message);
                    console.error(error);
                }
            }

            updateAnchorSection() {
                const section = document.getElementById('anchorSection');

                if (this.anchor_k === null || !this.currentSequence) {
                    section.style.display = 'none';
                    return;
                }

                section.style.display = 'block';
                document.getElementById('anchorK').textContent = `k = ${this.anchor_k}`;

                const prefix = this.currentSequence.getOEPrefixWithKEvens(this.anchor_k);
                document.getElementById('anchorOEPrefix').textContent = prefix;

                // Add congruence navigation
                const x0 = this.currentSequence.steps[0].x;
                const congruences = this.currentSequence.getCongruences(x0, this.anchor_k);
                const navHTML = formatCongruenceHTML(congruences);
                document.getElementById('anchorNav').innerHTML = navHTML;
            }

            loadSequenceForX(x, anchor_k = null) {
                // Called when navigating to a different x value
                this.anchor_k = !isNaN(anchor_k) && anchor_k !== null ? anchor_k : null;
                document.getElementById('x0Input').value = x;
                this.plotSequence();
            }

            clearCanvas() {
                this.renderer.clear();
                this.renderer.anchor_k = null;
                this.heatmapRenderer.clear();
                this.currentSequence = null;
                this.anchor_k = null;
                document.getElementById('oeSequence').textContent = '-';
                document.getElementById('seqLength').textContent = '-';
                document.getElementById('oeBlocks').textContent = '-';
                document.getElementById('infoPanel').style.display = 'none';
                document.getElementById('anchorSection').style.display = 'none';
            }

            loadExample(x0) {
                this.anchor_k = null;  // Clear anchor when loading example
                document.getElementById('x0Input').value = x0;
                this.plotSequence();
            }

            toggleEvenTerms() {
                const showEven = document.getElementById('showEvenTerms').checked;
                this.renderer.showEvenTerms = showEven;
                this.renderer.fitToView();
                this.renderer.render();
            }

            toggleLayer(layerName) {
                const layer = this.renderer.findLayer(layerName);
                if (layer) {
                    layer.enabled = !layer.enabled;
                    this.renderer.render();
                    this.updateAnimateButton();
                }
            }

            toggleAnimation() {
                this.renderer.startAnimation();
            }

            updateAnimateButton() {
                const xValueLayer = this.renderer.findLayer('X Values');
                const button = document.getElementById('animateButton');

                if (xValueLayer && xValueLayer.enabled) {
                    button.style.display = 'inline-block';
                    // Update button text based on animation state
                    if (this.renderer.animationT >= 1) {
                        button.textContent = 'Animate to (o,r)';
                    } else {
                        button.textContent = 'Animate to λₓ';
                    }
                } else {
                    button.style.display = 'none';
                }
            }
        }

        // Initialize application
        const app = new Application();

        // Plot default example on load
        window.addEventListener('load', () => {
            app.plotSequence();
            app.isInitialLoad = false;
            app.updateAnimateButton();
        });
    </script>
</body>
</html>
